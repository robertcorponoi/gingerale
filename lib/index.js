'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spritesheetToSprites = spritesheetToSprites;
exports.atlasToSprites = atlasToSprites;
Object.defineProperty(exports, "loadSpritesheet", {
  enumerable: true,
  get: function get() {
    return _loaders.loadSpritesheet;
  }
});
Object.defineProperty(exports, "loadXML", {
  enumerable: true,
  get: function get() {
    return _loaders.loadXML;
  }
});
Object.defineProperty(exports, "loadJSON", {
  enumerable: true,
  get: function get() {
    return _loaders.loadJSON;
  }
});

var _loaders = require("./loaders");

/**
 * Returns the individual sprites of a uniform spritesheet. A uniform spritesheet
 * is a spritesheet in which all of the individual sprites are the same size and
 * in a uniform fashion. Even if you have a uniform spritesheet but it has a XML
 * or JSON definition file, use `atlasToSprites` instead.
 * 
 * @param {HTMLImageElement} spritesheet The spritesheet image element to parse.
 * @param {number} spriteWidth The width of every individual sprite in the spritesheet.
 * @param {number} spriteHeight The height of every individual sprite in the spritesheet.
 * @param {SpritesheetToSpritesOptions} [options] The options that can be passed to this method.
 * @param {string} [options.name='sprite'] Sets the name of the individual sprites and used as the name for the file if downloaded.
 * @param {string} [options.crossOrigin=''] Sets the cross-origin property of the spritesheet if the spritesheet is hosted elsewhere.
 * 
 * @returns {Array<Sprite>} Returns the individual sprites from the spritesheet.
 */
function spritesheetToSprites(spritesheet, spriteWidth, spriteHeight) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var name = options.name ? options.name : 'sprite';
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d'); // If the `atlas` is not a `HTMLImageElement` then we throw an error as we no
  // longer handle loading in the parse methods.

  if (spritesheet instanceof HTMLImageElement === false) {
    throw new Error('The spritesheet provided is not a `HTMLImageElement`. If you need to load the atlas first, use the loader methods before passing it to the parser.');
  }

  canvas.width = spriteWidth;
  canvas.height = spriteHeight; // We need to know how many rows and columns of images we need to download.
  // This only works if all of the individual sprites in the spritesheet are
  // the same width and height.

  var cols = Math.floor(spritesheet.width / spriteWidth);
  var rows = Math.floor(spritesheet.height / spriteHeight);
  var locX = 0;
  var locY = 0;
  var counter = 1;
  var sprites = [];

  for (var i = 0; i < rows; ++i) {
    for (var j = 0; j < cols; ++j) {
      // Draw the portion of the spritesheet where the current sprite should be to the canvas.
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(spritesheet, locX, locY, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
      locX += spriteWidth; // Create the sprite object and add it to the `sprites` Array.

      var spriteImage = new Image();
      spriteImage.src = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream');
      var sprite = {
        name: "".concat(name, "_").concat(counter),
        x: locX,
        y: locY,
        width: spriteWidth,
        height: spriteHeight,
        isRotated: false,
        image: spriteImage
      };
      sprites.push(sprite);
      counter++;
    }

    locY += spriteHeight;
    locX = 0;
  }

  return sprites;
}
/**
 * Returns the individual sprites of an atlas. An atlas is a spritesheet in which
 * the sprites are in different orders and sizes with their positions defined by
 * a JSON or XML file.
 * 
 * @param {HTMLImageElement} spritesheet The texture atlas image element to parse.
 * @param {Object|XMLDocument} definition The XML or JSON file that defines the locations and sizes of the individual sprites in the spritesheet.
 * @param {AtlasToSpritesOptions} [options]
 * @param {string} [options.jsonPropertyPath='frames.$.frame'] The path to the sprite details in the JSON if a JSON definition is provided. See the documentation for the `AtlasToSpritesOptions` for a more in-depth example.
 * @param {string} [options.crossOrigin=''] Sets the cross-origin property of the atlas if the atlas is hosted elsewhere.
 * 
 * @returns {Array<Sprite>} Returns the individual sprites from the atlas.
 */


function atlasToSprites(spritesheet, definition) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d'); // If the `atlas` is not a `HTMLImageElement` then we throw an error as we no
  // longer handle loading in the parse methods.

  if (spritesheet instanceof HTMLImageElement === false) {
    throw new Error('The atlas provided is not a `HTMLImageElement`. If you need to load the atlas first, use the loader methods before passing it to the parser.');
  }

  var sprites = []; // Find out what type of data was provided, XML or JSON. If it's neither of
  // those then we throw an error.

  var dataType;
  if (definition instanceof XMLDocument) dataType = 'xml';else if (definition instanceof Object) dataType = 'json';else throw new Error('The definition must be either XML or JSON');

  switch (dataType) {
    case 'xml':
      var xmlDefinition = definition; // We want to get all nodes that have a `name`, `x`, and `y`, `width`, and 
      // `height` attributes.

      var spriteEntries = xmlDefinition.querySelectorAll('[x][y][width][height]'); // If the above is empty then maybe the `height` and `width` attributes are
      // actually `w` or `h` so we check for that.

      if (spriteEntries.length === 0) spriteEntries = xmlDefinition.querySelectorAll('[x][y][w][h]'); // If both of those are still empty then we can't proceed. Maybe in later
      // updates we'll make this more flexible but I haven't found cases for it
      // yet in the atlas' I've used.

      if (spriteEntries.length === 0) throw new Error('Could not find any rows with `x`, `y`, `width`, or `height` attributes');
      spriteEntries.forEach(function (entry) {
        // Keep track of the sprite's width and height and see if a `rotated` attribute exists.
        var width = parseInt(entry.getAttribute('width') || entry.getAttribute('w'));
        var height = parseInt(entry.getAttribute('height') || entry.getAttribute('h'));
        var isRotated = Boolean(entry.getAttribute('rotated'));
        var spriteWidth = isRotated ? height : width;
        var spriteHeight = isRotated ? width : height;
        if (!spriteWidth || !spriteHeight) throw new Error('Could not find a width or height for the sprite entries');
        var x = parseInt(entry.getAttribute('x'));
        var y = parseInt(entry.getAttribute('y')); // Set the canvas to the size of the sprite and then draw the sprite onto the canvas.

        canvas.width = spriteWidth;
        canvas.height = spriteHeight;
        ctx.drawImage(spritesheet, x, y, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
        var spriteImage = new Image();
        spriteImage.src = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream'); // Lastly we create the the Sprite object and add it to `sprites`.

        var sprite = {
          name: entry.getAttribute('name'),
          x: x,
          y: y,
          width: spriteWidth,
          height: spriteHeight,
          isRotated: isRotated,
          image: spriteImage
        };
        sprites.push(sprite);
      });
      break;

    case 'json':
      var jsonDefinition = definition; // If a property path as provided in the options then we use that otherwise we use the default one.

      var jsonPropertyPath = options.jsonPropertyPath ? options.jsonPropertyPath : 'frames.$.frame'; // Split the property path on periods so that we can use it to navigate the object.

      var propertyPathSplit = jsonPropertyPath.split('.'); // We need to know the index of the '$' character which denotes the property that contains the
      // individual sprite

      var indexOfSprite = propertyPathSplit.indexOf('$');
      var propertyPathBeforeSprite = propertyPathSplit.splice(0, indexOfSprite); // Now we get the part of the array up until `propertyPathBeforeSprite` so that we can get the
      // parts of the object that we can iterate. 

      var allSpritesInJSON = jsonDefinition;
      propertyPathBeforeSprite.forEach(function (property) {
        return allSpritesInJSON = allSpritesInJSON[property];
      }); // Get the last part of the propertyPathSplit without the $ element.

      var propertyDetailsPath = propertyPathSplit.slice(1);

      var _loop = function _loop(spriteDetails) {
        var spriteEntry = JSON.parse(JSON.stringify(allSpritesInJSON[spriteDetails])); // For each sprite in the JSON we have to finish the object lookup with the remaining values
        // of the `propertyDetailsPath`.

        propertyDetailsPath.forEach(function (property) {
          return spriteEntry = spriteEntry[property];
        });
        var entry = spriteEntry; // Keep track of the sprite's width and height and see if we need to rotate it.

        var width = entry.width || entry.w;
        var height = entry.height || entry.h;
        var isRotated = entry.rotated || allSpritesInJSON[spriteDetails].rotated || false;
        var spriteWidth = isRotated ? height : width;
        var spriteHeight = isRotated ? width : height;
        if (!spriteWidth || !spriteHeight) throw new Error('Could not find a width or height for the sprite entries'); // Set the canvas to the size of the sprite.

        canvas.width = spriteWidth;
        canvas.height = spriteHeight;
        ctx.drawImage(spritesheet, entry.x, entry.y, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
        var spriteImage = new Image();
        spriteImage.src = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream'); // Lastly we create the Sprite object and add it to `sprites`.

        var sprite = {
          name: entry.name || spriteDetails,
          x: entry.x,
          y: entry.y,
          width: spriteWidth,
          height: spriteHeight,
          isRotated: isRotated,
          image: spriteImage
        };
        sprites.push(sprite);
      };

      for (var spriteDetails in allSpritesInJSON) {
        _loop(spriteDetails);
      }

      break;
  }

  return sprites;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJzcHJpdGVzaGVldFRvU3ByaXRlcyIsInNwcml0ZXNoZWV0Iiwic3ByaXRlV2lkdGgiLCJzcHJpdGVIZWlnaHQiLCJvcHRpb25zIiwibmFtZSIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJIVE1MSW1hZ2VFbGVtZW50IiwiRXJyb3IiLCJ3aWR0aCIsImhlaWdodCIsImNvbHMiLCJNYXRoIiwiZmxvb3IiLCJyb3dzIiwibG9jWCIsImxvY1kiLCJjb3VudGVyIiwic3ByaXRlcyIsImkiLCJqIiwiY2xlYXJSZWN0IiwiZHJhd0ltYWdlIiwic3ByaXRlSW1hZ2UiLCJJbWFnZSIsInNyYyIsInRvRGF0YVVSTCIsInJlcGxhY2UiLCJzcHJpdGUiLCJ4IiwieSIsImlzUm90YXRlZCIsImltYWdlIiwicHVzaCIsImF0bGFzVG9TcHJpdGVzIiwiZGVmaW5pdGlvbiIsImRhdGFUeXBlIiwiWE1MRG9jdW1lbnQiLCJPYmplY3QiLCJ4bWxEZWZpbml0aW9uIiwic3ByaXRlRW50cmllcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsZW5ndGgiLCJmb3JFYWNoIiwiZW50cnkiLCJwYXJzZUludCIsImdldEF0dHJpYnV0ZSIsIkJvb2xlYW4iLCJqc29uRGVmaW5pdGlvbiIsImpzb25Qcm9wZXJ0eVBhdGgiLCJwcm9wZXJ0eVBhdGhTcGxpdCIsInNwbGl0IiwiaW5kZXhPZlNwcml0ZSIsImluZGV4T2YiLCJwcm9wZXJ0eVBhdGhCZWZvcmVTcHJpdGUiLCJzcGxpY2UiLCJhbGxTcHJpdGVzSW5KU09OIiwicHJvcGVydHkiLCJwcm9wZXJ0eURldGFpbHNQYXRoIiwic2xpY2UiLCJzcHJpdGVEZXRhaWxzIiwic3ByaXRlRW50cnkiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJ3IiwiaCIsInJvdGF0ZWQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVFBOztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7QUFlTyxTQUFTQSxvQkFBVCxDQUE4QkMsV0FBOUIsRUFBNkRDLFdBQTdELEVBQWtGQyxZQUFsRixFQUFrSztBQUFBLE1BQTFEQyxPQUEwRCx1RUFBbkIsRUFBbUI7QUFDdkssTUFBTUMsSUFBSSxHQUFHRCxPQUFPLENBQUNDLElBQVIsR0FBZUQsT0FBTyxDQUFDQyxJQUF2QixHQUE4QixRQUEzQztBQUVBLE1BQU1DLE1BQU0sR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLFFBQXZCLENBQWY7QUFDQSxNQUFNQyxHQUFHLEdBQUdILE1BQU0sQ0FBQ0ksVUFBUCxDQUFrQixJQUFsQixDQUFaLENBSnVLLENBTXZLO0FBQ0E7O0FBQ0EsTUFBSVQsV0FBVyxZQUFZVSxnQkFBdkIsS0FBNEMsS0FBaEQsRUFBdUQ7QUFDckQsVUFBTSxJQUFJQyxLQUFKLENBQVUsb0pBQVYsQ0FBTjtBQUNEOztBQUVETixFQUFBQSxNQUFNLENBQUNPLEtBQVAsR0FBZVgsV0FBZjtBQUNBSSxFQUFBQSxNQUFNLENBQUNRLE1BQVAsR0FBZ0JYLFlBQWhCLENBYnVLLENBZXZLO0FBQ0E7QUFDQTs7QUFDQSxNQUFJWSxJQUFJLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXaEIsV0FBVyxDQUFDWSxLQUFaLEdBQW9CWCxXQUEvQixDQUFYO0FBQ0EsTUFBSWdCLElBQUksR0FBR0YsSUFBSSxDQUFDQyxLQUFMLENBQVdoQixXQUFXLENBQUNhLE1BQVosR0FBcUJYLFlBQWhDLENBQVg7QUFFQSxNQUFJZ0IsSUFBSSxHQUFHLENBQVg7QUFDQSxNQUFJQyxJQUFJLEdBQUcsQ0FBWDtBQUNBLE1BQUlDLE9BQU8sR0FBRyxDQUFkO0FBRUEsTUFBTUMsT0FBc0IsR0FBRyxFQUEvQjs7QUFFQSxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdMLElBQXBCLEVBQTBCLEVBQUVLLENBQTVCLEVBQStCO0FBQzdCLFNBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR1QsSUFBcEIsRUFBMEIsRUFBRVMsQ0FBNUIsRUFBK0I7QUFDN0I7QUFDQWYsTUFBQUEsR0FBRyxDQUFDZ0IsU0FBSixDQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0JuQixNQUFNLENBQUNPLEtBQTNCLEVBQWtDUCxNQUFNLENBQUNRLE1BQXpDO0FBQ0FMLE1BQUFBLEdBQUcsQ0FBQ2lCLFNBQUosQ0FBY3pCLFdBQWQsRUFBMkJrQixJQUEzQixFQUFpQ0MsSUFBakMsRUFBdUNsQixXQUF2QyxFQUFvREMsWUFBcEQsRUFBa0UsQ0FBbEUsRUFBcUUsQ0FBckUsRUFBd0VELFdBQXhFLEVBQXFGQyxZQUFyRjtBQUVBZ0IsTUFBQUEsSUFBSSxJQUFJakIsV0FBUixDQUw2QixDQU83Qjs7QUFDQSxVQUFNeUIsV0FBVyxHQUFHLElBQUlDLEtBQUosRUFBcEI7QUFDQUQsTUFBQUEsV0FBVyxDQUFDRSxHQUFaLEdBQWtCdkIsTUFBTSxDQUFDd0IsU0FBUCxDQUFpQixXQUFqQixFQUE4QkMsT0FBOUIsQ0FBc0MsV0FBdEMsRUFBbUQsb0JBQW5ELENBQWxCO0FBRUEsVUFBTUMsTUFBYyxHQUFHO0FBQ3JCM0IsUUFBQUEsSUFBSSxZQUFLQSxJQUFMLGNBQWFnQixPQUFiLENBRGlCO0FBRXJCWSxRQUFBQSxDQUFDLEVBQUVkLElBRmtCO0FBR3JCZSxRQUFBQSxDQUFDLEVBQUVkLElBSGtCO0FBSXJCUCxRQUFBQSxLQUFLLEVBQUVYLFdBSmM7QUFLckJZLFFBQUFBLE1BQU0sRUFBRVgsWUFMYTtBQU1yQmdDLFFBQUFBLFNBQVMsRUFBRSxLQU5VO0FBT3JCQyxRQUFBQSxLQUFLLEVBQUVUO0FBUGMsT0FBdkI7QUFVQUwsTUFBQUEsT0FBTyxDQUFDZSxJQUFSLENBQWFMLE1BQWI7QUFDQVgsTUFBQUEsT0FBTztBQUNSOztBQUVERCxJQUFBQSxJQUFJLElBQUlqQixZQUFSO0FBQ0FnQixJQUFBQSxJQUFJLEdBQUcsQ0FBUDtBQUNEOztBQUVELFNBQU9HLE9BQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7QUFhTyxTQUFTZ0IsY0FBVCxDQUF3QnJDLFdBQXhCLEVBQXVEc0MsVUFBdkQsRUFBK0k7QUFBQSxNQUFwRG5DLE9BQW9ELHVFQUFuQixFQUFtQjtBQUNwSixNQUFNRSxNQUF5QixHQUFHQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBbEM7QUFDQSxNQUFNQyxHQUE2QixHQUFHSCxNQUFNLENBQUNJLFVBQVAsQ0FBa0IsSUFBbEIsQ0FBdEMsQ0FGb0osQ0FJcEo7QUFDQTs7QUFDQSxNQUFJVCxXQUFXLFlBQVlVLGdCQUF2QixLQUE0QyxLQUFoRCxFQUF1RDtBQUNyRCxVQUFNLElBQUlDLEtBQUosQ0FBVSw4SUFBVixDQUFOO0FBQ0Q7O0FBRUQsTUFBTVUsT0FBc0IsR0FBRyxFQUEvQixDQVZvSixDQVlwSjtBQUNBOztBQUNBLE1BQUlrQixRQUFKO0FBQ0EsTUFBSUQsVUFBVSxZQUFZRSxXQUExQixFQUF1Q0QsUUFBUSxHQUFHLEtBQVgsQ0FBdkMsS0FDSyxJQUFJRCxVQUFVLFlBQVlHLE1BQTFCLEVBQWtDRixRQUFRLEdBQUcsTUFBWCxDQUFsQyxLQUNBLE1BQU0sSUFBSTVCLEtBQUosQ0FBVSwyQ0FBVixDQUFOOztBQUVMLFVBQVE0QixRQUFSO0FBQ0UsU0FBSyxLQUFMO0FBQ0UsVUFBTUcsYUFBYSxHQUFHSixVQUF0QixDQURGLENBR0U7QUFDQTs7QUFDQSxVQUFJSyxhQUEwQyxHQUFHRCxhQUFhLENBQUNFLGdCQUFkLENBQStCLHVCQUEvQixDQUFqRCxDQUxGLENBT0U7QUFDQTs7QUFDQSxVQUFJRCxhQUFhLENBQUNFLE1BQWQsS0FBeUIsQ0FBN0IsRUFBZ0NGLGFBQWEsR0FBR0QsYUFBYSxDQUFDRSxnQkFBZCxDQUErQixjQUEvQixDQUFoQixDQVRsQyxDQVdFO0FBQ0E7QUFDQTs7QUFDQSxVQUFJRCxhQUFhLENBQUNFLE1BQWQsS0FBeUIsQ0FBN0IsRUFBZ0MsTUFBTSxJQUFJbEMsS0FBSixDQUFVLHdFQUFWLENBQU47QUFFaENnQyxNQUFBQSxhQUFhLENBQUNHLE9BQWQsQ0FBc0IsVUFBQUMsS0FBSyxFQUFJO0FBQzdCO0FBQ0EsWUFBTW5DLEtBQUssR0FBR29DLFFBQVEsQ0FBQ0QsS0FBSyxDQUFDRSxZQUFOLENBQW1CLE9BQW5CLEtBQWdDRixLQUFLLENBQUNFLFlBQU4sQ0FBbUIsR0FBbkIsQ0FBakMsQ0FBdEI7QUFDQSxZQUFNcEMsTUFBTSxHQUFHbUMsUUFBUSxDQUFDRCxLQUFLLENBQUNFLFlBQU4sQ0FBbUIsUUFBbkIsS0FBaUNGLEtBQUssQ0FBQ0UsWUFBTixDQUFtQixHQUFuQixDQUFsQyxDQUF2QjtBQUVBLFlBQU1mLFNBQVMsR0FBR2dCLE9BQU8sQ0FBQ0gsS0FBSyxDQUFDRSxZQUFOLENBQW1CLFNBQW5CLENBQUQsQ0FBekI7QUFDQSxZQUFNaEQsV0FBVyxHQUFHaUMsU0FBUyxHQUFHckIsTUFBSCxHQUFZRCxLQUF6QztBQUNBLFlBQU1WLFlBQVksR0FBR2dDLFNBQVMsR0FBR3RCLEtBQUgsR0FBV0MsTUFBekM7QUFFQSxZQUFJLENBQUNaLFdBQUQsSUFBZ0IsQ0FBQ0MsWUFBckIsRUFBbUMsTUFBTSxJQUFJUyxLQUFKLENBQVUseURBQVYsQ0FBTjtBQUVuQyxZQUFNcUIsQ0FBQyxHQUFHZ0IsUUFBUSxDQUFDRCxLQUFLLENBQUNFLFlBQU4sQ0FBbUIsR0FBbkIsQ0FBRCxDQUFsQjtBQUNBLFlBQU1oQixDQUFDLEdBQUdlLFFBQVEsQ0FBQ0QsS0FBSyxDQUFDRSxZQUFOLENBQW1CLEdBQW5CLENBQUQsQ0FBbEIsQ0FaNkIsQ0FjN0I7O0FBQ0E1QyxRQUFBQSxNQUFNLENBQUNPLEtBQVAsR0FBZVgsV0FBZjtBQUNBSSxRQUFBQSxNQUFNLENBQUNRLE1BQVAsR0FBZ0JYLFlBQWhCO0FBRUFNLFFBQUFBLEdBQUcsQ0FBQ2lCLFNBQUosQ0FBY3pCLFdBQWQsRUFBMkJnQyxDQUEzQixFQUE4QkMsQ0FBOUIsRUFBaUNoQyxXQUFqQyxFQUE4Q0MsWUFBOUMsRUFBNEQsQ0FBNUQsRUFBK0QsQ0FBL0QsRUFBa0VELFdBQWxFLEVBQStFQyxZQUEvRTtBQUVBLFlBQU13QixXQUFXLEdBQUcsSUFBSUMsS0FBSixFQUFwQjtBQUNBRCxRQUFBQSxXQUFXLENBQUNFLEdBQVosR0FBa0J2QixNQUFNLENBQUN3QixTQUFQLENBQWlCLFdBQWpCLEVBQThCQyxPQUE5QixDQUFzQyxXQUF0QyxFQUFtRCxvQkFBbkQsQ0FBbEIsQ0FyQjZCLENBdUI3Qjs7QUFDQSxZQUFNQyxNQUFjLEdBQUc7QUFDckIzQixVQUFBQSxJQUFJLEVBQUUyQyxLQUFLLENBQUNFLFlBQU4sQ0FBbUIsTUFBbkIsQ0FEZTtBQUVyQmpCLFVBQUFBLENBQUMsRUFBRUEsQ0FGa0I7QUFHckJDLFVBQUFBLENBQUMsRUFBRUEsQ0FIa0I7QUFJckJyQixVQUFBQSxLQUFLLEVBQUVYLFdBSmM7QUFLckJZLFVBQUFBLE1BQU0sRUFBRVgsWUFMYTtBQU1yQmdDLFVBQUFBLFNBQVMsRUFBRUEsU0FOVTtBQU9yQkMsVUFBQUEsS0FBSyxFQUFFVDtBQVBjLFNBQXZCO0FBU0FMLFFBQUFBLE9BQU8sQ0FBQ2UsSUFBUixDQUFhTCxNQUFiO0FBQ0QsT0FsQ0Q7QUFtQ0E7O0FBQ0YsU0FBSyxNQUFMO0FBQ0UsVUFBTW9CLGNBQW1CLEdBQUdiLFVBQTVCLENBREYsQ0FHRTs7QUFDQSxVQUFNYyxnQkFBZ0IsR0FBR2pELE9BQU8sQ0FBQ2lELGdCQUFSLEdBQTJCakQsT0FBTyxDQUFDaUQsZ0JBQW5DLEdBQXNELGdCQUEvRSxDQUpGLENBS0U7O0FBQ0EsVUFBTUMsaUJBQWlCLEdBQUdELGdCQUFnQixDQUFDRSxLQUFqQixDQUF1QixHQUF2QixDQUExQixDQU5GLENBUUU7QUFDQTs7QUFDQSxVQUFNQyxhQUFhLEdBQUdGLGlCQUFpQixDQUFDRyxPQUFsQixDQUEwQixHQUExQixDQUF0QjtBQUNBLFVBQU1DLHdCQUF3QixHQUFHSixpQkFBaUIsQ0FBQ0ssTUFBbEIsQ0FBeUIsQ0FBekIsRUFBNEJILGFBQTVCLENBQWpDLENBWEYsQ0FhRTtBQUNBOztBQUNBLFVBQUlJLGdCQUFnQixHQUFHUixjQUF2QjtBQUNBTSxNQUFBQSx3QkFBd0IsQ0FBQ1gsT0FBekIsQ0FBaUMsVUFBQWMsUUFBUTtBQUFBLGVBQUlELGdCQUFnQixHQUFHQSxnQkFBZ0IsQ0FBQ0MsUUFBRCxDQUF2QztBQUFBLE9BQXpDLEVBaEJGLENBa0JFOztBQUNBLFVBQU1DLG1CQUFtQixHQUFHUixpQkFBaUIsQ0FBQ1MsS0FBbEIsQ0FBd0IsQ0FBeEIsQ0FBNUI7O0FBbkJGLGlDQXFCV0MsYUFyQlg7QUFzQkksWUFBSUMsV0FBZ0IsR0FBR0MsSUFBSSxDQUFDQyxLQUFMLENBQVdELElBQUksQ0FBQ0UsU0FBTCxDQUFlUixnQkFBZ0IsQ0FBQ0ksYUFBRCxDQUEvQixDQUFYLENBQXZCLENBdEJKLENBd0JJO0FBQ0E7O0FBQ0FGLFFBQUFBLG1CQUFtQixDQUFDZixPQUFwQixDQUE0QixVQUFBYyxRQUFRO0FBQUEsaUJBQUlJLFdBQVcsR0FBR0EsV0FBVyxDQUFDSixRQUFELENBQTdCO0FBQUEsU0FBcEM7QUFFQSxZQUFNYixLQUFzQixHQUFHaUIsV0FBL0IsQ0E1QkosQ0E4Qkk7O0FBQ0EsWUFBTXBELEtBQUssR0FBR21DLEtBQUssQ0FBQ25DLEtBQU4sSUFBZW1DLEtBQUssQ0FBQ3FCLENBQW5DO0FBQ0EsWUFBTXZELE1BQU0sR0FBR2tDLEtBQUssQ0FBQ2xDLE1BQU4sSUFBZ0JrQyxLQUFLLENBQUNzQixDQUFyQztBQUNBLFlBQU1uQyxTQUFTLEdBQUdhLEtBQUssQ0FBQ3VCLE9BQU4sSUFBaUJYLGdCQUFnQixDQUFDSSxhQUFELENBQWhCLENBQWdDTyxPQUFqRCxJQUE0RCxLQUE5RTtBQUVBLFlBQU1yRSxXQUFXLEdBQUdpQyxTQUFTLEdBQUdyQixNQUFILEdBQVlELEtBQXpDO0FBQ0EsWUFBTVYsWUFBWSxHQUFHZ0MsU0FBUyxHQUFHdEIsS0FBSCxHQUFXQyxNQUF6QztBQUVBLFlBQUksQ0FBQ1osV0FBRCxJQUFnQixDQUFDQyxZQUFyQixFQUFtQyxNQUFNLElBQUlTLEtBQUosQ0FBVSx5REFBVixDQUFOLENBdEN2QyxDQXdDSTs7QUFDQU4sUUFBQUEsTUFBTSxDQUFDTyxLQUFQLEdBQWVYLFdBQWY7QUFDQUksUUFBQUEsTUFBTSxDQUFDUSxNQUFQLEdBQWdCWCxZQUFoQjtBQUVBTSxRQUFBQSxHQUFHLENBQUNpQixTQUFKLENBQWN6QixXQUFkLEVBQTJCK0MsS0FBSyxDQUFDZixDQUFqQyxFQUFvQ2UsS0FBSyxDQUFDZCxDQUExQyxFQUE2Q2hDLFdBQTdDLEVBQTBEQyxZQUExRCxFQUF3RSxDQUF4RSxFQUEyRSxDQUEzRSxFQUE4RUQsV0FBOUUsRUFBMkZDLFlBQTNGO0FBRUEsWUFBTXdCLFdBQVcsR0FBRyxJQUFJQyxLQUFKLEVBQXBCO0FBQ0FELFFBQUFBLFdBQVcsQ0FBQ0UsR0FBWixHQUFrQnZCLE1BQU0sQ0FBQ3dCLFNBQVAsQ0FBaUIsV0FBakIsRUFBOEJDLE9BQTlCLENBQXNDLFdBQXRDLEVBQW1ELG9CQUFuRCxDQUFsQixDQS9DSixDQWlESTs7QUFDQSxZQUFNQyxNQUFjLEdBQUc7QUFDckIzQixVQUFBQSxJQUFJLEVBQUUyQyxLQUFLLENBQUMzQyxJQUFOLElBQWMyRCxhQURDO0FBRXJCL0IsVUFBQUEsQ0FBQyxFQUFFZSxLQUFLLENBQUNmLENBRlk7QUFHckJDLFVBQUFBLENBQUMsRUFBRWMsS0FBSyxDQUFDZCxDQUhZO0FBSXJCckIsVUFBQUEsS0FBSyxFQUFFWCxXQUpjO0FBS3JCWSxVQUFBQSxNQUFNLEVBQUVYLFlBTGE7QUFNckJnQyxVQUFBQSxTQUFTLEVBQUVBLFNBTlU7QUFPckJDLFVBQUFBLEtBQUssRUFBRVQ7QUFQYyxTQUF2QjtBQVNBTCxRQUFBQSxPQUFPLENBQUNlLElBQVIsQ0FBYUwsTUFBYjtBQTNESjs7QUFxQkUsV0FBSyxJQUFJZ0MsYUFBVCxJQUEwQkosZ0JBQTFCLEVBQTRDO0FBQUEsY0FBbkNJLGFBQW1DO0FBdUMzQzs7QUFDRDtBQWxISjs7QUFxSEEsU0FBTzFDLE9BQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3Nwcml0ZSc7XHJcbmltcG9ydCB7IEF0bGFzU3ByaXRlRGF0YSB9IGZyb20gJy4vaW50ZXJmYWNlcy9hdGxhc19zcHJpdGVfZGF0YSc7XHJcblxyXG5pbXBvcnQgeyBBdGxhc1RvU3ByaXRlc09wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMvYXRsYXNfdG9fc3ByaXRlc19vcHRpb25zJztcclxuaW1wb3J0IHsgU3ByaXRlc2hlZXRUb1Nwcml0ZXNPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zL3Nwcml0ZXNoZWV0X3RvX3Nwcml0ZXNfb3B0aW9ucyc7XHJcblxyXG5pbXBvcnQgeyBsb2FkU3ByaXRlc2hlZXQsIGxvYWRYTUwsIGxvYWRKU09OIH0gZnJvbSAnLi9sb2FkZXJzJztcclxuXHJcbmV4cG9ydCB7XHJcbiAgbG9hZFhNTCxcclxuICBsb2FkSlNPTixcclxuICBsb2FkU3ByaXRlc2hlZXQsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIHNwcml0ZXMgb2YgYSB1bmlmb3JtIHNwcml0ZXNoZWV0LiBBIHVuaWZvcm0gc3ByaXRlc2hlZXRcclxuICogaXMgYSBzcHJpdGVzaGVldCBpbiB3aGljaCBhbGwgb2YgdGhlIGluZGl2aWR1YWwgc3ByaXRlcyBhcmUgdGhlIHNhbWUgc2l6ZSBhbmRcclxuICogaW4gYSB1bmlmb3JtIGZhc2hpb24uIEV2ZW4gaWYgeW91IGhhdmUgYSB1bmlmb3JtIHNwcml0ZXNoZWV0IGJ1dCBpdCBoYXMgYSBYTUxcclxuICogb3IgSlNPTiBkZWZpbml0aW9uIGZpbGUsIHVzZSBgYXRsYXNUb1Nwcml0ZXNgIGluc3RlYWQuXHJcbiAqIFxyXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IHNwcml0ZXNoZWV0IFRoZSBzcHJpdGVzaGVldCBpbWFnZSBlbGVtZW50IHRvIHBhcnNlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3ByaXRlV2lkdGggVGhlIHdpZHRoIG9mIGV2ZXJ5IGluZGl2aWR1YWwgc3ByaXRlIGluIHRoZSBzcHJpdGVzaGVldC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHNwcml0ZUhlaWdodCBUaGUgaGVpZ2h0IG9mIGV2ZXJ5IGluZGl2aWR1YWwgc3ByaXRlIGluIHRoZSBzcHJpdGVzaGVldC5cclxuICogQHBhcmFtIHtTcHJpdGVzaGVldFRvU3ByaXRlc09wdGlvbnN9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lPSdzcHJpdGUnXSBTZXRzIHRoZSBuYW1lIG9mIHRoZSBpbmRpdmlkdWFsIHNwcml0ZXMgYW5kIHVzZWQgYXMgdGhlIG5hbWUgZm9yIHRoZSBmaWxlIGlmIGRvd25sb2FkZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbj0nJ10gU2V0cyB0aGUgY3Jvc3Mtb3JpZ2luIHByb3BlcnR5IG9mIHRoZSBzcHJpdGVzaGVldCBpZiB0aGUgc3ByaXRlc2hlZXQgaXMgaG9zdGVkIGVsc2V3aGVyZS5cclxuICogXHJcbiAqIEByZXR1cm5zIHtBcnJheTxTcHJpdGU+fSBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIHNwcml0ZXMgZnJvbSB0aGUgc3ByaXRlc2hlZXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3ByaXRlc2hlZXRUb1Nwcml0ZXMoc3ByaXRlc2hlZXQ6IEhUTUxJbWFnZUVsZW1lbnQsIHNwcml0ZVdpZHRoOiBudW1iZXIsIHNwcml0ZUhlaWdodDogbnVtYmVyLCBvcHRpb25zOiBTcHJpdGVzaGVldFRvU3ByaXRlc09wdGlvbnMgPSB7fSk6IEFycmF5PFNwcml0ZT4ge1xyXG4gIGNvbnN0IG5hbWUgPSBvcHRpb25zLm5hbWUgPyBvcHRpb25zLm5hbWUgOiAnc3ByaXRlJztcclxuXHJcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhO1xyXG5cclxuICAvLyBJZiB0aGUgYGF0bGFzYCBpcyBub3QgYSBgSFRNTEltYWdlRWxlbWVudGAgdGhlbiB3ZSB0aHJvdyBhbiBlcnJvciBhcyB3ZSBub1xyXG4gIC8vIGxvbmdlciBoYW5kbGUgbG9hZGluZyBpbiB0aGUgcGFyc2UgbWV0aG9kcy5cclxuICBpZiAoc3ByaXRlc2hlZXQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ID09PSBmYWxzZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3ByaXRlc2hlZXQgcHJvdmlkZWQgaXMgbm90IGEgYEhUTUxJbWFnZUVsZW1lbnRgLiBJZiB5b3UgbmVlZCB0byBsb2FkIHRoZSBhdGxhcyBmaXJzdCwgdXNlIHRoZSBsb2FkZXIgbWV0aG9kcyBiZWZvcmUgcGFzc2luZyBpdCB0byB0aGUgcGFyc2VyLicpO1xyXG4gIH1cclxuXHJcbiAgY2FudmFzLndpZHRoID0gc3ByaXRlV2lkdGg7XHJcbiAgY2FudmFzLmhlaWdodCA9IHNwcml0ZUhlaWdodDtcclxuXHJcbiAgLy8gV2UgbmVlZCB0byBrbm93IGhvdyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgaW1hZ2VzIHdlIG5lZWQgdG8gZG93bmxvYWQuXHJcbiAgLy8gVGhpcyBvbmx5IHdvcmtzIGlmIGFsbCBvZiB0aGUgaW5kaXZpZHVhbCBzcHJpdGVzIGluIHRoZSBzcHJpdGVzaGVldCBhcmVcclxuICAvLyB0aGUgc2FtZSB3aWR0aCBhbmQgaGVpZ2h0LlxyXG4gIGxldCBjb2xzID0gTWF0aC5mbG9vcihzcHJpdGVzaGVldC53aWR0aCAvIHNwcml0ZVdpZHRoKTtcclxuICBsZXQgcm93cyA9IE1hdGguZmxvb3Ioc3ByaXRlc2hlZXQuaGVpZ2h0IC8gc3ByaXRlSGVpZ2h0KTtcclxuXHJcbiAgbGV0IGxvY1ggPSAwO1xyXG4gIGxldCBsb2NZID0gMDtcclxuICBsZXQgY291bnRlciA9IDE7XHJcblxyXG4gIGNvbnN0IHNwcml0ZXM6IEFycmF5PFNwcml0ZT4gPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyArK2kpIHtcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgKytqKSB7XHJcbiAgICAgIC8vIERyYXcgdGhlIHBvcnRpb24gb2YgdGhlIHNwcml0ZXNoZWV0IHdoZXJlIHRoZSBjdXJyZW50IHNwcml0ZSBzaG91bGQgYmUgdG8gdGhlIGNhbnZhcy5cclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKHNwcml0ZXNoZWV0LCBsb2NYLCBsb2NZLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0LCAwLCAwLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0KTtcclxuXHJcbiAgICAgIGxvY1ggKz0gc3ByaXRlV2lkdGg7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNwcml0ZSBvYmplY3QgYW5kIGFkZCBpdCB0byB0aGUgYHNwcml0ZXNgIEFycmF5LlxyXG4gICAgICBjb25zdCBzcHJpdGVJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICBzcHJpdGVJbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKS5yZXBsYWNlKCdpbWFnZS9wbmcnLCAnaW1hZ2Uvb2N0ZXQtc3RyZWFtJyk7XHJcblxyXG4gICAgICBjb25zdCBzcHJpdGU6IFNwcml0ZSA9IHtcclxuICAgICAgICBuYW1lOiBgJHtuYW1lfV8ke2NvdW50ZXJ9YCxcclxuICAgICAgICB4OiBsb2NYLFxyXG4gICAgICAgIHk6IGxvY1ksXHJcbiAgICAgICAgd2lkdGg6IHNwcml0ZVdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogc3ByaXRlSGVpZ2h0LFxyXG4gICAgICAgIGlzUm90YXRlZDogZmFsc2UsXHJcbiAgICAgICAgaW1hZ2U6IHNwcml0ZUltYWdlLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc3ByaXRlcy5wdXNoKHNwcml0ZSk7XHJcbiAgICAgIGNvdW50ZXIrKztcclxuICAgIH1cclxuXHJcbiAgICBsb2NZICs9IHNwcml0ZUhlaWdodDtcclxuICAgIGxvY1ggPSAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNwcml0ZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIHNwcml0ZXMgb2YgYW4gYXRsYXMuIEFuIGF0bGFzIGlzIGEgc3ByaXRlc2hlZXQgaW4gd2hpY2hcclxuICogdGhlIHNwcml0ZXMgYXJlIGluIGRpZmZlcmVudCBvcmRlcnMgYW5kIHNpemVzIHdpdGggdGhlaXIgcG9zaXRpb25zIGRlZmluZWQgYnlcclxuICogYSBKU09OIG9yIFhNTCBmaWxlLlxyXG4gKiBcclxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBzcHJpdGVzaGVldCBUaGUgdGV4dHVyZSBhdGxhcyBpbWFnZSBlbGVtZW50IHRvIHBhcnNlLlxyXG4gKiBAcGFyYW0ge09iamVjdHxYTUxEb2N1bWVudH0gZGVmaW5pdGlvbiBUaGUgWE1MIG9yIEpTT04gZmlsZSB0aGF0IGRlZmluZXMgdGhlIGxvY2F0aW9ucyBhbmQgc2l6ZXMgb2YgdGhlIGluZGl2aWR1YWwgc3ByaXRlcyBpbiB0aGUgc3ByaXRlc2hlZXQuXHJcbiAqIEBwYXJhbSB7QXRsYXNUb1Nwcml0ZXNPcHRpb25zfSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmpzb25Qcm9wZXJ0eVBhdGg9J2ZyYW1lcy4kLmZyYW1lJ10gVGhlIHBhdGggdG8gdGhlIHNwcml0ZSBkZXRhaWxzIGluIHRoZSBKU09OIGlmIGEgSlNPTiBkZWZpbml0aW9uIGlzIHByb3ZpZGVkLiBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgQXRsYXNUb1Nwcml0ZXNPcHRpb25zYCBmb3IgYSBtb3JlIGluLWRlcHRoIGV4YW1wbGUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbj0nJ10gU2V0cyB0aGUgY3Jvc3Mtb3JpZ2luIHByb3BlcnR5IG9mIHRoZSBhdGxhcyBpZiB0aGUgYXRsYXMgaXMgaG9zdGVkIGVsc2V3aGVyZS5cclxuICogXHJcbiAqIEByZXR1cm5zIHtBcnJheTxTcHJpdGU+fSBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIHNwcml0ZXMgZnJvbSB0aGUgYXRsYXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXRsYXNUb1Nwcml0ZXMoc3ByaXRlc2hlZXQ6IEhUTUxJbWFnZUVsZW1lbnQsIGRlZmluaXRpb246IChPYmplY3QgfCBYTUxEb2N1bWVudCksIG9wdGlvbnM6IEF0bGFzVG9TcHJpdGVzT3B0aW9ucyA9IHt9KTogQXJyYXk8U3ByaXRlPiB7XHJcbiAgY29uc3QgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gIGNvbnN0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhO1xyXG5cclxuICAvLyBJZiB0aGUgYGF0bGFzYCBpcyBub3QgYSBgSFRNTEltYWdlRWxlbWVudGAgdGhlbiB3ZSB0aHJvdyBhbiBlcnJvciBhcyB3ZSBub1xyXG4gIC8vIGxvbmdlciBoYW5kbGUgbG9hZGluZyBpbiB0aGUgcGFyc2UgbWV0aG9kcy5cclxuICBpZiAoc3ByaXRlc2hlZXQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ID09PSBmYWxzZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXRsYXMgcHJvdmlkZWQgaXMgbm90IGEgYEhUTUxJbWFnZUVsZW1lbnRgLiBJZiB5b3UgbmVlZCB0byBsb2FkIHRoZSBhdGxhcyBmaXJzdCwgdXNlIHRoZSBsb2FkZXIgbWV0aG9kcyBiZWZvcmUgcGFzc2luZyBpdCB0byB0aGUgcGFyc2VyLicpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3ByaXRlczogQXJyYXk8U3ByaXRlPiA9IFtdO1xyXG5cclxuICAvLyBGaW5kIG91dCB3aGF0IHR5cGUgb2YgZGF0YSB3YXMgcHJvdmlkZWQsIFhNTCBvciBKU09OLiBJZiBpdCdzIG5laXRoZXIgb2ZcclxuICAvLyB0aG9zZSB0aGVuIHdlIHRocm93IGFuIGVycm9yLlxyXG4gIGxldCBkYXRhVHlwZTtcclxuICBpZiAoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIFhNTERvY3VtZW50KSBkYXRhVHlwZSA9ICd4bWwnO1xyXG4gIGVsc2UgaWYgKGRlZmluaXRpb24gaW5zdGFuY2VvZiBPYmplY3QpIGRhdGFUeXBlID0gJ2pzb24nO1xyXG4gIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVmaW5pdGlvbiBtdXN0IGJlIGVpdGhlciBYTUwgb3IgSlNPTicpO1xyXG5cclxuICBzd2l0Y2ggKGRhdGFUeXBlKSB7XHJcbiAgICBjYXNlICd4bWwnOlxyXG4gICAgICBjb25zdCB4bWxEZWZpbml0aW9uID0gZGVmaW5pdGlvbiBhcyBYTUxEb2N1bWVudDtcclxuXHJcbiAgICAgIC8vIFdlIHdhbnQgdG8gZ2V0IGFsbCBub2RlcyB0aGF0IGhhdmUgYSBgbmFtZWAsIGB4YCwgYW5kIGB5YCwgYHdpZHRoYCwgYW5kIFxyXG4gICAgICAvLyBgaGVpZ2h0YCBhdHRyaWJ1dGVzLlxyXG4gICAgICBsZXQgc3ByaXRlRW50cmllczogTm9kZUxpc3RPZjxBdGxhc1Nwcml0ZURhdGE+ID0geG1sRGVmaW5pdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdbeF1beV1bd2lkdGhdW2hlaWdodF0nKTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBhYm92ZSBpcyBlbXB0eSB0aGVuIG1heWJlIHRoZSBgaGVpZ2h0YCBhbmQgYHdpZHRoYCBhdHRyaWJ1dGVzIGFyZVxyXG4gICAgICAvLyBhY3R1YWxseSBgd2Agb3IgYGhgIHNvIHdlIGNoZWNrIGZvciB0aGF0LlxyXG4gICAgICBpZiAoc3ByaXRlRW50cmllcy5sZW5ndGggPT09IDApIHNwcml0ZUVudHJpZXMgPSB4bWxEZWZpbml0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ1t4XVt5XVt3XVtoXScpO1xyXG5cclxuICAgICAgLy8gSWYgYm90aCBvZiB0aG9zZSBhcmUgc3RpbGwgZW1wdHkgdGhlbiB3ZSBjYW4ndCBwcm9jZWVkLiBNYXliZSBpbiBsYXRlclxyXG4gICAgICAvLyB1cGRhdGVzIHdlJ2xsIG1ha2UgdGhpcyBtb3JlIGZsZXhpYmxlIGJ1dCBJIGhhdmVuJ3QgZm91bmQgY2FzZXMgZm9yIGl0XHJcbiAgICAgIC8vIHlldCBpbiB0aGUgYXRsYXMnIEkndmUgdXNlZC5cclxuICAgICAgaWYgKHNwcml0ZUVudHJpZXMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGFueSByb3dzIHdpdGggYHhgLCBgeWAsIGB3aWR0aGAsIG9yIGBoZWlnaHRgIGF0dHJpYnV0ZXMnKTtcclxuXHJcbiAgICAgIHNwcml0ZUVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XHJcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgc3ByaXRlJ3Mgd2lkdGggYW5kIGhlaWdodCBhbmQgc2VlIGlmIGEgYHJvdGF0ZWRgIGF0dHJpYnV0ZSBleGlzdHMuXHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChlbnRyeS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykhIHx8IGVudHJ5LmdldEF0dHJpYnV0ZSgndycpISk7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyc2VJbnQoZW50cnkuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSEgfHwgZW50cnkuZ2V0QXR0cmlidXRlKCdoJykhKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNSb3RhdGVkID0gQm9vbGVhbihlbnRyeS5nZXRBdHRyaWJ1dGUoJ3JvdGF0ZWQnKSk7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlV2lkdGggPSBpc1JvdGF0ZWQgPyBoZWlnaHQgOiB3aWR0aDtcclxuICAgICAgICBjb25zdCBzcHJpdGVIZWlnaHQgPSBpc1JvdGF0ZWQgPyB3aWR0aCA6IGhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKCFzcHJpdGVXaWR0aCB8fCAhc3ByaXRlSGVpZ2h0KSB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGEgd2lkdGggb3IgaGVpZ2h0IGZvciB0aGUgc3ByaXRlIGVudHJpZXMnKTtcclxuXHJcbiAgICAgICAgY29uc3QgeCA9IHBhcnNlSW50KGVudHJ5LmdldEF0dHJpYnV0ZSgneCcpISk7XHJcbiAgICAgICAgY29uc3QgeSA9IHBhcnNlSW50KGVudHJ5LmdldEF0dHJpYnV0ZSgneScpISk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgY2FudmFzIHRvIHRoZSBzaXplIG9mIHRoZSBzcHJpdGUgYW5kIHRoZW4gZHJhdyB0aGUgc3ByaXRlIG9udG8gdGhlIGNhbnZhcy5cclxuICAgICAgICBjYW52YXMud2lkdGggPSBzcHJpdGVXaWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gc3ByaXRlSGVpZ2h0O1xyXG5cclxuICAgICAgICBjdHguZHJhd0ltYWdlKHNwcml0ZXNoZWV0LCB4LCB5LCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0LCAwLCAwLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3ByaXRlSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBzcHJpdGVJbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKS5yZXBsYWNlKCdpbWFnZS9wbmcnLCAnaW1hZ2Uvb2N0ZXQtc3RyZWFtJyk7XHJcblxyXG4gICAgICAgIC8vIExhc3RseSB3ZSBjcmVhdGUgdGhlIHRoZSBTcHJpdGUgb2JqZWN0IGFuZCBhZGQgaXQgdG8gYHNwcml0ZXNgLlxyXG4gICAgICAgIGNvbnN0IHNwcml0ZTogU3ByaXRlID0ge1xyXG4gICAgICAgICAgbmFtZTogZW50cnkuZ2V0QXR0cmlidXRlKCduYW1lJykhLFxyXG4gICAgICAgICAgeDogeCxcclxuICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICB3aWR0aDogc3ByaXRlV2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IHNwcml0ZUhlaWdodCxcclxuICAgICAgICAgIGlzUm90YXRlZDogaXNSb3RhdGVkLFxyXG4gICAgICAgICAgaW1hZ2U6IHNwcml0ZUltYWdlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc3ByaXRlcy5wdXNoKHNwcml0ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2pzb24nOlxyXG4gICAgICBjb25zdCBqc29uRGVmaW5pdGlvbjogYW55ID0gZGVmaW5pdGlvbiBhcyBPYmplY3Q7XHJcblxyXG4gICAgICAvLyBJZiBhIHByb3BlcnR5IHBhdGggYXMgcHJvdmlkZWQgaW4gdGhlIG9wdGlvbnMgdGhlbiB3ZSB1c2UgdGhhdCBvdGhlcndpc2Ugd2UgdXNlIHRoZSBkZWZhdWx0IG9uZS5cclxuICAgICAgY29uc3QganNvblByb3BlcnR5UGF0aCA9IG9wdGlvbnMuanNvblByb3BlcnR5UGF0aCA/IG9wdGlvbnMuanNvblByb3BlcnR5UGF0aCA6ICdmcmFtZXMuJC5mcmFtZSc7XHJcbiAgICAgIC8vIFNwbGl0IHRoZSBwcm9wZXJ0eSBwYXRoIG9uIHBlcmlvZHMgc28gdGhhdCB3ZSBjYW4gdXNlIGl0IHRvIG5hdmlnYXRlIHRoZSBvYmplY3QuXHJcbiAgICAgIGNvbnN0IHByb3BlcnR5UGF0aFNwbGl0ID0ganNvblByb3BlcnR5UGF0aC5zcGxpdCgnLicpO1xyXG5cclxuICAgICAgLy8gV2UgbmVlZCB0byBrbm93IHRoZSBpbmRleCBvZiB0aGUgJyQnIGNoYXJhY3RlciB3aGljaCBkZW5vdGVzIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZVxyXG4gICAgICAvLyBpbmRpdmlkdWFsIHNwcml0ZVxyXG4gICAgICBjb25zdCBpbmRleE9mU3ByaXRlID0gcHJvcGVydHlQYXRoU3BsaXQuaW5kZXhPZignJCcpO1xyXG4gICAgICBjb25zdCBwcm9wZXJ0eVBhdGhCZWZvcmVTcHJpdGUgPSBwcm9wZXJ0eVBhdGhTcGxpdC5zcGxpY2UoMCwgaW5kZXhPZlNwcml0ZSk7XHJcblxyXG4gICAgICAvLyBOb3cgd2UgZ2V0IHRoZSBwYXJ0IG9mIHRoZSBhcnJheSB1cCB1bnRpbCBgcHJvcGVydHlQYXRoQmVmb3JlU3ByaXRlYCBzbyB0aGF0IHdlIGNhbiBnZXQgdGhlXHJcbiAgICAgIC8vIHBhcnRzIG9mIHRoZSBvYmplY3QgdGhhdCB3ZSBjYW4gaXRlcmF0ZS4gXHJcbiAgICAgIGxldCBhbGxTcHJpdGVzSW5KU09OID0ganNvbkRlZmluaXRpb247XHJcbiAgICAgIHByb3BlcnR5UGF0aEJlZm9yZVNwcml0ZS5mb3JFYWNoKHByb3BlcnR5ID0+IGFsbFNwcml0ZXNJbkpTT04gPSBhbGxTcHJpdGVzSW5KU09OW3Byb3BlcnR5XSk7XHJcblxyXG4gICAgICAvLyBHZXQgdGhlIGxhc3QgcGFydCBvZiB0aGUgcHJvcGVydHlQYXRoU3BsaXQgd2l0aG91dCB0aGUgJCBlbGVtZW50LlxyXG4gICAgICBjb25zdCBwcm9wZXJ0eURldGFpbHNQYXRoID0gcHJvcGVydHlQYXRoU3BsaXQuc2xpY2UoMSk7XHJcblxyXG4gICAgICBmb3IgKGxldCBzcHJpdGVEZXRhaWxzIGluIGFsbFNwcml0ZXNJbkpTT04pIHtcclxuICAgICAgICBsZXQgc3ByaXRlRW50cnk6IGFueSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYWxsU3ByaXRlc0luSlNPTltzcHJpdGVEZXRhaWxzXSkpO1xyXG5cclxuICAgICAgICAvLyBGb3IgZWFjaCBzcHJpdGUgaW4gdGhlIEpTT04gd2UgaGF2ZSB0byBmaW5pc2ggdGhlIG9iamVjdCBsb29rdXAgd2l0aCB0aGUgcmVtYWluaW5nIHZhbHVlc1xyXG4gICAgICAgIC8vIG9mIHRoZSBgcHJvcGVydHlEZXRhaWxzUGF0aGAuXHJcbiAgICAgICAgcHJvcGVydHlEZXRhaWxzUGF0aC5mb3JFYWNoKHByb3BlcnR5ID0+IHNwcml0ZUVudHJ5ID0gc3ByaXRlRW50cnlbcHJvcGVydHldKTtcclxuXHJcbiAgICAgICAgY29uc3QgZW50cnk6IEF0bGFzU3ByaXRlRGF0YSA9IHNwcml0ZUVudHJ5O1xyXG5cclxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBzcHJpdGUncyB3aWR0aCBhbmQgaGVpZ2h0IGFuZCBzZWUgaWYgd2UgbmVlZCB0byByb3RhdGUgaXQuXHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBlbnRyeS53aWR0aCB8fCBlbnRyeS53O1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGVudHJ5LmhlaWdodCB8fCBlbnRyeS5oO1xyXG4gICAgICAgIGNvbnN0IGlzUm90YXRlZCA9IGVudHJ5LnJvdGF0ZWQgfHwgYWxsU3ByaXRlc0luSlNPTltzcHJpdGVEZXRhaWxzXS5yb3RhdGVkIHx8IGZhbHNlO1xyXG5cclxuICAgICAgICBjb25zdCBzcHJpdGVXaWR0aCA9IGlzUm90YXRlZCA/IGhlaWdodCA6IHdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZUhlaWdodCA9IGlzUm90YXRlZCA/IHdpZHRoIDogaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoIXNwcml0ZVdpZHRoIHx8ICFzcHJpdGVIZWlnaHQpIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYSB3aWR0aCBvciBoZWlnaHQgZm9yIHRoZSBzcHJpdGUgZW50cmllcycpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGNhbnZhcyB0byB0aGUgc2l6ZSBvZiB0aGUgc3ByaXRlLlxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHNwcml0ZVdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzcHJpdGVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2Uoc3ByaXRlc2hlZXQsIGVudHJ5LngsIGVudHJ5LnksIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQsIDAsIDAsIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQpO1xyXG5cclxuICAgICAgICBjb25zdCBzcHJpdGVJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIHNwcml0ZUltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpLnJlcGxhY2UoJ2ltYWdlL3BuZycsICdpbWFnZS9vY3RldC1zdHJlYW0nKTtcclxuXHJcbiAgICAgICAgLy8gTGFzdGx5IHdlIGNyZWF0ZSB0aGUgU3ByaXRlIG9iamVjdCBhbmQgYWRkIGl0IHRvIGBzcHJpdGVzYC5cclxuICAgICAgICBjb25zdCBzcHJpdGU6IFNwcml0ZSA9IHtcclxuICAgICAgICAgIG5hbWU6IGVudHJ5Lm5hbWUgfHwgc3ByaXRlRGV0YWlscyxcclxuICAgICAgICAgIHg6IGVudHJ5LngsXHJcbiAgICAgICAgICB5OiBlbnRyeS55LFxyXG4gICAgICAgICAgd2lkdGg6IHNwcml0ZVdpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiBzcHJpdGVIZWlnaHQsXHJcbiAgICAgICAgICBpc1JvdGF0ZWQ6IGlzUm90YXRlZCxcclxuICAgICAgICAgIGltYWdlOiBzcHJpdGVJbWFnZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHNwcml0ZXMucHVzaChzcHJpdGUpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNwcml0ZXM7XHJcbn0iXX0=