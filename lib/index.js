'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spritesheetToSprites = spritesheetToSprites;
exports.atlasToSprites = atlasToSprites;
Object.defineProperty(exports, "loadSpritesheet", {
  enumerable: true,
  get: function get() {
    return _loaders.loadSpritesheet;
  }
});
Object.defineProperty(exports, "loadXML", {
  enumerable: true,
  get: function get() {
    return _loaders.loadXML;
  }
});
Object.defineProperty(exports, "loadJSON", {
  enumerable: true,
  get: function get() {
    return _loaders.loadJSON;
  }
});

var _loaders = require("./loaders");

/**
 * Returns the individual sprites of a uniform spritesheet. A uniform spritesheet
 * is a spritesheet in which all of the individual sprites are the same size and
 * in a uniform fashion. Even if you have a uniform spritesheet but it has a XML
 * or JSON definition file, use `atlasToSprites` instead.
 * 
 * @param {HTMLImageElement} spritesheet The spritesheet image element to parse.
 * @param {number} spriteWidth The width of every individual sprite in the spritesheet.
 * @param {number} spriteHeight The height of every individual sprite in the spritesheet.
 * @param {SpritesheetToSpritesOptions} [options] The options that can be passed to this method.
 * @param {string} [options.name='sprite'] Sets the name of the individual sprites and used as the name for the file if downloaded.
 * @param {string} [options.crossOrigin=''] Sets the cross-origin property of the spritesheet if the spritesheet is hosted elsewhere.
 * @param {boolean} [options.download=false] Indicates whether the sprites should be downloaded after they're retrieved or not.
 * 
 * @returns {Array<Sprite>} Returns the individual sprites from the spritesheet.
 */
function spritesheetToSprites(spritesheet, spriteWidth, spriteHeight) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var name = options.name ? options.name : 'sprite';
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d'); // If the `atlas` is not a `HTMLImageElement` then we throw an error as we no
  // longer handle loading in the parse methods.

  if (spritesheet instanceof HTMLImageElement === false) {
    throw new Error('The spritesheet provided is not a `HTMLImageElement`. If you need to load the atlas first, use the loader methods before passing it to the parser.');
  }

  canvas.width = spriteWidth;
  canvas.height = spriteHeight; // We need to know how many rows and columns of images we need to download.
  // This only works if all of the individual sprites in the spritesheet are
  // the same width and height.

  var cols = Math.floor(spritesheet.width / spriteWidth);
  var rows = Math.floor(spritesheet.height / spriteHeight);
  var locX = 0;
  var locY = 0;
  var counter = 1;
  var sprites = [];

  for (var i = 0; i < rows; ++i) {
    for (var j = 0; j < cols; ++j) {
      // Draw the portion of the spritesheet where the current sprite should be to the canvas.
      ctx.drawImage(spritesheet, locX, locY, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
      locX += spriteWidth;
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Create the sprite object and add it to the `sprites` Array.

      var spriteImage = new Image();
      spriteImage.src = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream');
      var sprite = {
        name: "".concat(name, "_").concat(counter),
        x: locX,
        y: locY,
        width: spriteWidth,
        height: spriteHeight,
        isRotated: false,
        image: spriteImage
      };
      sprites.push(sprite);
      counter++;
    }

    locY += spriteHeight;
    locX = 0;
  }

  return sprites;
}
/**
 * Returns the individual sprites of an atlas. An atlas is a spritesheet in which
 * the sprites are in different orders and sizes with their positions defined by
 * a JSON or XML file.
 * 
 * @param {HTMLImageElement} spritesheet The texture atlas image element to parse.
 * @param {Object|XMLDocument} definition The XML or JSON file that defines the locations and sizes of the individual sprites in the spritesheet.
 * @param {AtlasToSpritesOptions} [options]
 * @param {string} [options.jsonPropertyPath='frames.$.frame'] The path to the sprite details in the JSON if a JSON definition is provided. See the documentation for the `AtlasToSpritesOptions` for a more in-depth example.
 * @param {string} [options.crossOrigin=''] Sets the cross-origin property of the atlas if the atlas is hosted elsewhere.
 * @param {boolean} [options.download=false] Indicates whether the sprites should be downloaded after they're retrieved or not.
 * 
 * @returns {Array<Sprite>} Returns the individual sprites from the atlas.
 */


function atlasToSprites(spritesheet, definition) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d'); // If the `atlas` is not a `HTMLImageElement` then we throw an error as we no
  // longer handle loading in the parse methods.

  if (spritesheet instanceof HTMLImageElement === false) {
    throw new Error('The atlas provided is not a `HTMLImageElement`. If you need to load the atlas first, use the loader methods before passing it to the parser.');
  }

  var sprites = []; // Find out what type of data was provided, XML or JSON. If it's neither of
  // those then we throw an error.

  var dataType;
  if (definition instanceof XMLDocument) dataType = 'xml';else if (definition instanceof Object) dataType = 'json';else throw new Error('The definition must be either XML or JSON');

  switch (dataType) {
    case 'xml':
      var xmlDefinition = definition; // We want to get all nodes that have a `name`, `x`, and `y`, `width`, and 
      // `height` attributes.

      var spriteEntries = xmlDefinition.querySelectorAll('[x][y][width][height]'); // If the above is empty then maybe the `height` and `width` attributes are
      // actually `w` or `h` so we check for that.

      if (spriteEntries.length === 0) spriteEntries = xmlDefinition.querySelectorAll('[x][y][w][h]'); // If both of those are still empty then we can't proceed. Maybe in later
      // updates we'll make this more flexible but I haven't found cases for it
      // yet in the atlas' I've used.

      if (spriteEntries.length === 0) throw new Error('Could not find any rows with `x`, `y`, `width`, or `height` attributes');
      spriteEntries.forEach(function (entry) {
        // Keep track of the sprite's width and height and see if a `rotated` attribute exists.
        var width = parseInt(entry.getAttribute('width') || entry.getAttribute('w'));
        var height = parseInt(entry.getAttribute('height') || entry.getAttribute('h'));
        var isRotated = Boolean(entry.getAttribute('rotated'));
        var spriteWidth = isRotated ? height : width;
        var spriteHeight = isRotated ? width : height;
        if (!spriteWidth || !spriteHeight) throw new Error('Could not find a width or height for the sprite entries');
        var x = parseInt(entry.getAttribute('x'));
        var y = parseInt(entry.getAttribute('y')); // Set the canvas to the size of the sprite and then draw the sprite onto the canvas.

        canvas.width = spriteWidth;
        canvas.height = spriteHeight;
        ctx.drawImage(spritesheet, x, y, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
        var spriteImage = new Image();
        spriteImage.src = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream'); // Lastly we create the the Sprite object and add it to `sprites`.

        var sprite = {
          name: entry.getAttribute('name'),
          x: x,
          y: y,
          width: spriteWidth,
          height: spriteHeight,
          isRotated: isRotated,
          image: spriteImage
        };
        sprites.push(sprite);
      });
      break;

    case 'json':
      var jsonDefinition = definition; // If a property path as provided in the options then we use that otherwise we use the default one.

      var jsonPropertyPath = options.jsonPropertyPath ? options.jsonPropertyPath : 'frames.$.frame'; // Split the property path on periods so that we can use it to navigate the object.

      var propertyPathSplit = jsonPropertyPath.split('.'); // We need to know the index of the '$' character which denotes the property that contains the
      // individual sprite

      var indexOfSprite = propertyPathSplit.indexOf('$');
      var propertyPathBeforeSprite = propertyPathSplit.splice(0, indexOfSprite); // Now we get the part of the array up until `propertyPathBeforeSprite` so that we can get the
      // parts of the object that we can iterate. 

      var allSpritesInJSON = jsonDefinition;
      propertyPathBeforeSprite.forEach(function (property) {
        return allSpritesInJSON = allSpritesInJSON[property];
      }); // Get the last part of the propertyPathSplit without the $ element.

      var propertyDetailsPath = propertyPathSplit.slice(1);

      var _loop = function _loop(spriteDetails) {
        var spriteEntry = JSON.parse(JSON.stringify(allSpritesInJSON[spriteDetails])); // For each sprite in the JSON we have to finish the object lookup with the remaining values
        // of the `propertyDetailsPath`.

        propertyDetailsPath.forEach(function (property) {
          return spriteEntry = spriteEntry[property];
        });
        var entry = spriteEntry; // Keep track of the sprite's width and height and see if we need to rotate it.

        var width = entry.width || entry.w;
        var height = entry.height || entry.h;
        var isRotated = entry.rotated || allSpritesInJSON[spriteDetails].rotated || false;
        var spriteWidth = isRotated ? height : width;
        var spriteHeight = isRotated ? width : height;
        if (!spriteWidth || !spriteHeight) throw new Error('Could not find a width or height for the sprite entries'); // Set the canvas to the size of the sprite.

        canvas.width = spriteWidth;
        canvas.height = spriteHeight;
        ctx.drawImage(spritesheet, entry.x, entry.y, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
        var spriteImage = new Image();
        spriteImage.src = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream'); // Lastly we create the Sprite object and add it to `sprites`.

        var sprite = {
          name: entry.name || spriteDetails,
          x: entry.x,
          y: entry.y,
          width: spriteWidth,
          height: spriteHeight,
          isRotated: isRotated,
          image: spriteImage
        };
        sprites.push(sprite);
      };

      for (var spriteDetails in allSpritesInJSON) {
        _loop(spriteDetails);
      }

      break;
  }

  return sprites;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJzcHJpdGVzaGVldFRvU3ByaXRlcyIsInNwcml0ZXNoZWV0Iiwic3ByaXRlV2lkdGgiLCJzcHJpdGVIZWlnaHQiLCJvcHRpb25zIiwibmFtZSIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJIVE1MSW1hZ2VFbGVtZW50IiwiRXJyb3IiLCJ3aWR0aCIsImhlaWdodCIsImNvbHMiLCJNYXRoIiwiZmxvb3IiLCJyb3dzIiwibG9jWCIsImxvY1kiLCJjb3VudGVyIiwic3ByaXRlcyIsImkiLCJqIiwiZHJhd0ltYWdlIiwiY2xlYXJSZWN0Iiwic3ByaXRlSW1hZ2UiLCJJbWFnZSIsInNyYyIsInRvRGF0YVVSTCIsInJlcGxhY2UiLCJzcHJpdGUiLCJ4IiwieSIsImlzUm90YXRlZCIsImltYWdlIiwicHVzaCIsImF0bGFzVG9TcHJpdGVzIiwiZGVmaW5pdGlvbiIsImRhdGFUeXBlIiwiWE1MRG9jdW1lbnQiLCJPYmplY3QiLCJ4bWxEZWZpbml0aW9uIiwic3ByaXRlRW50cmllcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsZW5ndGgiLCJmb3JFYWNoIiwiZW50cnkiLCJwYXJzZUludCIsImdldEF0dHJpYnV0ZSIsIkJvb2xlYW4iLCJqc29uRGVmaW5pdGlvbiIsImpzb25Qcm9wZXJ0eVBhdGgiLCJwcm9wZXJ0eVBhdGhTcGxpdCIsInNwbGl0IiwiaW5kZXhPZlNwcml0ZSIsImluZGV4T2YiLCJwcm9wZXJ0eVBhdGhCZWZvcmVTcHJpdGUiLCJzcGxpY2UiLCJhbGxTcHJpdGVzSW5KU09OIiwicHJvcGVydHkiLCJwcm9wZXJ0eURldGFpbHNQYXRoIiwic2xpY2UiLCJzcHJpdGVEZXRhaWxzIiwic3ByaXRlRW50cnkiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJ3IiwiaCIsInJvdGF0ZWQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVFBOztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JPLFNBQVNBLG9CQUFULENBQThCQyxXQUE5QixFQUE2REMsV0FBN0QsRUFBa0ZDLFlBQWxGLEVBQWtLO0FBQUEsTUFBMURDLE9BQTBELHVFQUFuQixFQUFtQjtBQUN2SyxNQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQ0MsSUFBUixHQUFlRCxPQUFPLENBQUNDLElBQXZCLEdBQThCLFFBQTNDO0FBRUEsTUFBTUMsTUFBTSxHQUFHQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtBQUNBLE1BQU1DLEdBQUcsR0FBR0gsTUFBTSxDQUFDSSxVQUFQLENBQWtCLElBQWxCLENBQVosQ0FKdUssQ0FNdks7QUFDQTs7QUFDQSxNQUFJVCxXQUFXLFlBQVlVLGdCQUF2QixLQUE0QyxLQUFoRCxFQUF1RDtBQUNyRCxVQUFNLElBQUlDLEtBQUosQ0FBVSxvSkFBVixDQUFOO0FBQ0Q7O0FBRUROLEVBQUFBLE1BQU0sQ0FBQ08sS0FBUCxHQUFlWCxXQUFmO0FBQ0FJLEVBQUFBLE1BQU0sQ0FBQ1EsTUFBUCxHQUFnQlgsWUFBaEIsQ0FidUssQ0Fldks7QUFDQTtBQUNBOztBQUNBLE1BQUlZLElBQUksR0FBR0MsSUFBSSxDQUFDQyxLQUFMLENBQVdoQixXQUFXLENBQUNZLEtBQVosR0FBb0JYLFdBQS9CLENBQVg7QUFDQSxNQUFJZ0IsSUFBSSxHQUFHRixJQUFJLENBQUNDLEtBQUwsQ0FBV2hCLFdBQVcsQ0FBQ2EsTUFBWixHQUFxQlgsWUFBaEMsQ0FBWDtBQUVBLE1BQUlnQixJQUFJLEdBQUcsQ0FBWDtBQUNBLE1BQUlDLElBQUksR0FBRyxDQUFYO0FBQ0EsTUFBSUMsT0FBTyxHQUFHLENBQWQ7QUFFQSxNQUFNQyxPQUFzQixHQUFHLEVBQS9COztBQUVBLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0wsSUFBcEIsRUFBMEIsRUFBRUssQ0FBNUIsRUFBK0I7QUFDN0IsU0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHVCxJQUFwQixFQUEwQixFQUFFUyxDQUE1QixFQUErQjtBQUM3QjtBQUNBZixNQUFBQSxHQUFHLENBQUNnQixTQUFKLENBQWN4QixXQUFkLEVBQTJCa0IsSUFBM0IsRUFBaUNDLElBQWpDLEVBQXVDbEIsV0FBdkMsRUFBb0RDLFlBQXBELEVBQWtFLENBQWxFLEVBQXFFLENBQXJFLEVBQXdFRCxXQUF4RSxFQUFxRkMsWUFBckY7QUFFQWdCLE1BQUFBLElBQUksSUFBSWpCLFdBQVI7QUFFQU8sTUFBQUEsR0FBRyxDQUFDaUIsU0FBSixDQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0JwQixNQUFNLENBQUNPLEtBQTNCLEVBQWtDUCxNQUFNLENBQUNRLE1BQXpDLEVBTjZCLENBUTdCOztBQUNBLFVBQU1hLFdBQVcsR0FBRyxJQUFJQyxLQUFKLEVBQXBCO0FBQ0FELE1BQUFBLFdBQVcsQ0FBQ0UsR0FBWixHQUFrQnZCLE1BQU0sQ0FBQ3dCLFNBQVAsQ0FBaUIsV0FBakIsRUFBOEJDLE9BQTlCLENBQXNDLFdBQXRDLEVBQW1ELG9CQUFuRCxDQUFsQjtBQUVBLFVBQU1DLE1BQWMsR0FBRztBQUNyQjNCLFFBQUFBLElBQUksWUFBS0EsSUFBTCxjQUFhZ0IsT0FBYixDQURpQjtBQUVyQlksUUFBQUEsQ0FBQyxFQUFFZCxJQUZrQjtBQUdyQmUsUUFBQUEsQ0FBQyxFQUFFZCxJQUhrQjtBQUlyQlAsUUFBQUEsS0FBSyxFQUFFWCxXQUpjO0FBS3JCWSxRQUFBQSxNQUFNLEVBQUVYLFlBTGE7QUFNckJnQyxRQUFBQSxTQUFTLEVBQUUsS0FOVTtBQU9yQkMsUUFBQUEsS0FBSyxFQUFFVDtBQVBjLE9BQXZCO0FBVUFMLE1BQUFBLE9BQU8sQ0FBQ2UsSUFBUixDQUFhTCxNQUFiO0FBQ0FYLE1BQUFBLE9BQU87QUFDUjs7QUFFREQsSUFBQUEsSUFBSSxJQUFJakIsWUFBUjtBQUNBZ0IsSUFBQUEsSUFBSSxHQUFHLENBQVA7QUFDRDs7QUFFRCxTQUFPRyxPQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OztBQWNPLFNBQVNnQixjQUFULENBQXdCckMsV0FBeEIsRUFBdURzQyxVQUF2RCxFQUErSTtBQUFBLE1BQXBEbkMsT0FBb0QsdUVBQW5CLEVBQW1CO0FBQ3BKLE1BQU1FLE1BQXlCLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixRQUF2QixDQUFsQztBQUNBLE1BQU1DLEdBQTZCLEdBQUdILE1BQU0sQ0FBQ0ksVUFBUCxDQUFrQixJQUFsQixDQUF0QyxDQUZvSixDQUlwSjtBQUNBOztBQUNBLE1BQUlULFdBQVcsWUFBWVUsZ0JBQXZCLEtBQTRDLEtBQWhELEVBQXVEO0FBQ3JELFVBQU0sSUFBSUMsS0FBSixDQUFVLDhJQUFWLENBQU47QUFDRDs7QUFFRCxNQUFNVSxPQUFzQixHQUFHLEVBQS9CLENBVm9KLENBWXBKO0FBQ0E7O0FBQ0EsTUFBSWtCLFFBQUo7QUFDQSxNQUFJRCxVQUFVLFlBQVlFLFdBQTFCLEVBQXVDRCxRQUFRLEdBQUcsS0FBWCxDQUF2QyxLQUNLLElBQUlELFVBQVUsWUFBWUcsTUFBMUIsRUFBa0NGLFFBQVEsR0FBRyxNQUFYLENBQWxDLEtBQ0EsTUFBTSxJQUFJNUIsS0FBSixDQUFVLDJDQUFWLENBQU47O0FBRUwsVUFBUTRCLFFBQVI7QUFDRSxTQUFLLEtBQUw7QUFDRSxVQUFNRyxhQUFhLEdBQUdKLFVBQXRCLENBREYsQ0FHRTtBQUNBOztBQUNBLFVBQUlLLGFBQTBDLEdBQUdELGFBQWEsQ0FBQ0UsZ0JBQWQsQ0FBK0IsdUJBQS9CLENBQWpELENBTEYsQ0FPRTtBQUNBOztBQUNBLFVBQUlELGFBQWEsQ0FBQ0UsTUFBZCxLQUF5QixDQUE3QixFQUFnQ0YsYUFBYSxHQUFHRCxhQUFhLENBQUNFLGdCQUFkLENBQStCLGNBQS9CLENBQWhCLENBVGxDLENBV0U7QUFDQTtBQUNBOztBQUNBLFVBQUlELGFBQWEsQ0FBQ0UsTUFBZCxLQUF5QixDQUE3QixFQUFnQyxNQUFNLElBQUlsQyxLQUFKLENBQVUsd0VBQVYsQ0FBTjtBQUVoQ2dDLE1BQUFBLGFBQWEsQ0FBQ0csT0FBZCxDQUFzQixVQUFBQyxLQUFLLEVBQUk7QUFDN0I7QUFDQSxZQUFNbkMsS0FBSyxHQUFHb0MsUUFBUSxDQUFDRCxLQUFLLENBQUNFLFlBQU4sQ0FBbUIsT0FBbkIsS0FBZ0NGLEtBQUssQ0FBQ0UsWUFBTixDQUFtQixHQUFuQixDQUFqQyxDQUF0QjtBQUNBLFlBQU1wQyxNQUFNLEdBQUdtQyxRQUFRLENBQUNELEtBQUssQ0FBQ0UsWUFBTixDQUFtQixRQUFuQixLQUFpQ0YsS0FBSyxDQUFDRSxZQUFOLENBQW1CLEdBQW5CLENBQWxDLENBQXZCO0FBRUEsWUFBTWYsU0FBUyxHQUFHZ0IsT0FBTyxDQUFDSCxLQUFLLENBQUNFLFlBQU4sQ0FBbUIsU0FBbkIsQ0FBRCxDQUF6QjtBQUNBLFlBQU1oRCxXQUFXLEdBQUdpQyxTQUFTLEdBQUdyQixNQUFILEdBQVlELEtBQXpDO0FBQ0EsWUFBTVYsWUFBWSxHQUFHZ0MsU0FBUyxHQUFHdEIsS0FBSCxHQUFXQyxNQUF6QztBQUVBLFlBQUksQ0FBQ1osV0FBRCxJQUFnQixDQUFDQyxZQUFyQixFQUFtQyxNQUFNLElBQUlTLEtBQUosQ0FBVSx5REFBVixDQUFOO0FBRW5DLFlBQU1xQixDQUFDLEdBQUdnQixRQUFRLENBQUNELEtBQUssQ0FBQ0UsWUFBTixDQUFtQixHQUFuQixDQUFELENBQWxCO0FBQ0EsWUFBTWhCLENBQUMsR0FBR2UsUUFBUSxDQUFDRCxLQUFLLENBQUNFLFlBQU4sQ0FBbUIsR0FBbkIsQ0FBRCxDQUFsQixDQVo2QixDQWM3Qjs7QUFDQTVDLFFBQUFBLE1BQU0sQ0FBQ08sS0FBUCxHQUFlWCxXQUFmO0FBQ0FJLFFBQUFBLE1BQU0sQ0FBQ1EsTUFBUCxHQUFnQlgsWUFBaEI7QUFFQU0sUUFBQUEsR0FBRyxDQUFDZ0IsU0FBSixDQUFjeEIsV0FBZCxFQUEyQmdDLENBQTNCLEVBQThCQyxDQUE5QixFQUFpQ2hDLFdBQWpDLEVBQThDQyxZQUE5QyxFQUE0RCxDQUE1RCxFQUErRCxDQUEvRCxFQUFrRUQsV0FBbEUsRUFBK0VDLFlBQS9FO0FBRUEsWUFBTXdCLFdBQVcsR0FBRyxJQUFJQyxLQUFKLEVBQXBCO0FBQ0FELFFBQUFBLFdBQVcsQ0FBQ0UsR0FBWixHQUFrQnZCLE1BQU0sQ0FBQ3dCLFNBQVAsQ0FBaUIsV0FBakIsRUFBOEJDLE9BQTlCLENBQXNDLFdBQXRDLEVBQW1ELG9CQUFuRCxDQUFsQixDQXJCNkIsQ0F1QjdCOztBQUNBLFlBQU1DLE1BQWMsR0FBRztBQUNyQjNCLFVBQUFBLElBQUksRUFBRTJDLEtBQUssQ0FBQ0UsWUFBTixDQUFtQixNQUFuQixDQURlO0FBRXJCakIsVUFBQUEsQ0FBQyxFQUFFQSxDQUZrQjtBQUdyQkMsVUFBQUEsQ0FBQyxFQUFFQSxDQUhrQjtBQUlyQnJCLFVBQUFBLEtBQUssRUFBRVgsV0FKYztBQUtyQlksVUFBQUEsTUFBTSxFQUFFWCxZQUxhO0FBTXJCZ0MsVUFBQUEsU0FBUyxFQUFFQSxTQU5VO0FBT3JCQyxVQUFBQSxLQUFLLEVBQUVUO0FBUGMsU0FBdkI7QUFTQUwsUUFBQUEsT0FBTyxDQUFDZSxJQUFSLENBQWFMLE1BQWI7QUFDRCxPQWxDRDtBQW1DQTs7QUFDRixTQUFLLE1BQUw7QUFDRSxVQUFNb0IsY0FBbUIsR0FBR2IsVUFBNUIsQ0FERixDQUdFOztBQUNBLFVBQU1jLGdCQUFnQixHQUFHakQsT0FBTyxDQUFDaUQsZ0JBQVIsR0FBMkJqRCxPQUFPLENBQUNpRCxnQkFBbkMsR0FBc0QsZ0JBQS9FLENBSkYsQ0FLRTs7QUFDQSxVQUFNQyxpQkFBaUIsR0FBR0QsZ0JBQWdCLENBQUNFLEtBQWpCLENBQXVCLEdBQXZCLENBQTFCLENBTkYsQ0FRRTtBQUNBOztBQUNBLFVBQU1DLGFBQWEsR0FBR0YsaUJBQWlCLENBQUNHLE9BQWxCLENBQTBCLEdBQTFCLENBQXRCO0FBQ0EsVUFBTUMsd0JBQXdCLEdBQUdKLGlCQUFpQixDQUFDSyxNQUFsQixDQUF5QixDQUF6QixFQUE0QkgsYUFBNUIsQ0FBakMsQ0FYRixDQWFFO0FBQ0E7O0FBQ0EsVUFBSUksZ0JBQWdCLEdBQUdSLGNBQXZCO0FBQ0FNLE1BQUFBLHdCQUF3QixDQUFDWCxPQUF6QixDQUFpQyxVQUFBYyxRQUFRO0FBQUEsZUFBSUQsZ0JBQWdCLEdBQUdBLGdCQUFnQixDQUFDQyxRQUFELENBQXZDO0FBQUEsT0FBekMsRUFoQkYsQ0FrQkU7O0FBQ0EsVUFBTUMsbUJBQW1CLEdBQUdSLGlCQUFpQixDQUFDUyxLQUFsQixDQUF3QixDQUF4QixDQUE1Qjs7QUFuQkYsaUNBcUJXQyxhQXJCWDtBQXNCSSxZQUFJQyxXQUFnQixHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDRSxTQUFMLENBQWVSLGdCQUFnQixDQUFDSSxhQUFELENBQS9CLENBQVgsQ0FBdkIsQ0F0QkosQ0F3Qkk7QUFDQTs7QUFDQUYsUUFBQUEsbUJBQW1CLENBQUNmLE9BQXBCLENBQTRCLFVBQUFjLFFBQVE7QUFBQSxpQkFBSUksV0FBVyxHQUFHQSxXQUFXLENBQUNKLFFBQUQsQ0FBN0I7QUFBQSxTQUFwQztBQUVBLFlBQU1iLEtBQXNCLEdBQUdpQixXQUEvQixDQTVCSixDQThCSTs7QUFDQSxZQUFNcEQsS0FBSyxHQUFHbUMsS0FBSyxDQUFDbkMsS0FBTixJQUFlbUMsS0FBSyxDQUFDcUIsQ0FBbkM7QUFDQSxZQUFNdkQsTUFBTSxHQUFHa0MsS0FBSyxDQUFDbEMsTUFBTixJQUFnQmtDLEtBQUssQ0FBQ3NCLENBQXJDO0FBQ0EsWUFBTW5DLFNBQVMsR0FBR2EsS0FBSyxDQUFDdUIsT0FBTixJQUFpQlgsZ0JBQWdCLENBQUNJLGFBQUQsQ0FBaEIsQ0FBZ0NPLE9BQWpELElBQTRELEtBQTlFO0FBRUEsWUFBTXJFLFdBQVcsR0FBR2lDLFNBQVMsR0FBR3JCLE1BQUgsR0FBWUQsS0FBekM7QUFDQSxZQUFNVixZQUFZLEdBQUdnQyxTQUFTLEdBQUd0QixLQUFILEdBQVdDLE1BQXpDO0FBRUEsWUFBSSxDQUFDWixXQUFELElBQWdCLENBQUNDLFlBQXJCLEVBQW1DLE1BQU0sSUFBSVMsS0FBSixDQUFVLHlEQUFWLENBQU4sQ0F0Q3ZDLENBd0NJOztBQUNBTixRQUFBQSxNQUFNLENBQUNPLEtBQVAsR0FBZVgsV0FBZjtBQUNBSSxRQUFBQSxNQUFNLENBQUNRLE1BQVAsR0FBZ0JYLFlBQWhCO0FBRUFNLFFBQUFBLEdBQUcsQ0FBQ2dCLFNBQUosQ0FBY3hCLFdBQWQsRUFBMkIrQyxLQUFLLENBQUNmLENBQWpDLEVBQW9DZSxLQUFLLENBQUNkLENBQTFDLEVBQTZDaEMsV0FBN0MsRUFBMERDLFlBQTFELEVBQXdFLENBQXhFLEVBQTJFLENBQTNFLEVBQThFRCxXQUE5RSxFQUEyRkMsWUFBM0Y7QUFFQSxZQUFNd0IsV0FBVyxHQUFHLElBQUlDLEtBQUosRUFBcEI7QUFDQUQsUUFBQUEsV0FBVyxDQUFDRSxHQUFaLEdBQWtCdkIsTUFBTSxDQUFDd0IsU0FBUCxDQUFpQixXQUFqQixFQUE4QkMsT0FBOUIsQ0FBc0MsV0FBdEMsRUFBbUQsb0JBQW5ELENBQWxCLENBL0NKLENBaURJOztBQUNBLFlBQU1DLE1BQWMsR0FBRztBQUNyQjNCLFVBQUFBLElBQUksRUFBRTJDLEtBQUssQ0FBQzNDLElBQU4sSUFBYzJELGFBREM7QUFFckIvQixVQUFBQSxDQUFDLEVBQUVlLEtBQUssQ0FBQ2YsQ0FGWTtBQUdyQkMsVUFBQUEsQ0FBQyxFQUFFYyxLQUFLLENBQUNkLENBSFk7QUFJckJyQixVQUFBQSxLQUFLLEVBQUVYLFdBSmM7QUFLckJZLFVBQUFBLE1BQU0sRUFBRVgsWUFMYTtBQU1yQmdDLFVBQUFBLFNBQVMsRUFBRUEsU0FOVTtBQU9yQkMsVUFBQUEsS0FBSyxFQUFFVDtBQVBjLFNBQXZCO0FBU0FMLFFBQUFBLE9BQU8sQ0FBQ2UsSUFBUixDQUFhTCxNQUFiO0FBM0RKOztBQXFCRSxXQUFLLElBQUlnQyxhQUFULElBQTBCSixnQkFBMUIsRUFBNEM7QUFBQSxjQUFuQ0ksYUFBbUM7QUF1QzNDOztBQUNEO0FBbEhKOztBQXFIQSxTQUFPMUMsT0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL2ludGVyZmFjZXMvc3ByaXRlJztcclxuaW1wb3J0IHsgQXRsYXNTcHJpdGVEYXRhIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2F0bGFzX3Nwcml0ZV9kYXRhJztcclxuXHJcbmltcG9ydCB7IEF0bGFzVG9TcHJpdGVzT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucy9hdGxhc190b19zcHJpdGVzX29wdGlvbnMnO1xyXG5pbXBvcnQgeyBTcHJpdGVzaGVldFRvU3ByaXRlc09wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMvc3ByaXRlc2hlZXRfdG9fc3ByaXRlc19vcHRpb25zJztcclxuXHJcbmltcG9ydCB7IGxvYWRTcHJpdGVzaGVldCwgbG9hZFhNTCwgbG9hZEpTT04gfSBmcm9tICcuL2xvYWRlcnMnO1xyXG5cclxuZXhwb3J0IHtcclxuICBsb2FkWE1MLFxyXG4gIGxvYWRKU09OLFxyXG4gIGxvYWRTcHJpdGVzaGVldCxcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGluZGl2aWR1YWwgc3ByaXRlcyBvZiBhIHVuaWZvcm0gc3ByaXRlc2hlZXQuIEEgdW5pZm9ybSBzcHJpdGVzaGVldFxyXG4gKiBpcyBhIHNwcml0ZXNoZWV0IGluIHdoaWNoIGFsbCBvZiB0aGUgaW5kaXZpZHVhbCBzcHJpdGVzIGFyZSB0aGUgc2FtZSBzaXplIGFuZFxyXG4gKiBpbiBhIHVuaWZvcm0gZmFzaGlvbi4gRXZlbiBpZiB5b3UgaGF2ZSBhIHVuaWZvcm0gc3ByaXRlc2hlZXQgYnV0IGl0IGhhcyBhIFhNTFxyXG4gKiBvciBKU09OIGRlZmluaXRpb24gZmlsZSwgdXNlIGBhdGxhc1RvU3ByaXRlc2AgaW5zdGVhZC5cclxuICogXHJcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gc3ByaXRlc2hlZXQgVGhlIHNwcml0ZXNoZWV0IGltYWdlIGVsZW1lbnQgdG8gcGFyc2UuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcHJpdGVXaWR0aCBUaGUgd2lkdGggb2YgZXZlcnkgaW5kaXZpZHVhbCBzcHJpdGUgaW4gdGhlIHNwcml0ZXNoZWV0LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3ByaXRlSGVpZ2h0IFRoZSBoZWlnaHQgb2YgZXZlcnkgaW5kaXZpZHVhbCBzcHJpdGUgaW4gdGhlIHNwcml0ZXNoZWV0LlxyXG4gKiBAcGFyYW0ge1Nwcml0ZXNoZWV0VG9TcHJpdGVzT3B0aW9uc30gW29wdGlvbnNdIFRoZSBvcHRpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGlzIG1ldGhvZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm5hbWU9J3Nwcml0ZSddIFNldHMgdGhlIG5hbWUgb2YgdGhlIGluZGl2aWR1YWwgc3ByaXRlcyBhbmQgdXNlZCBhcyB0aGUgbmFtZSBmb3IgdGhlIGZpbGUgaWYgZG93bmxvYWRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNyb3NzT3JpZ2luPScnXSBTZXRzIHRoZSBjcm9zcy1vcmlnaW4gcHJvcGVydHkgb2YgdGhlIHNwcml0ZXNoZWV0IGlmIHRoZSBzcHJpdGVzaGVldCBpcyBob3N0ZWQgZWxzZXdoZXJlLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRvd25sb2FkPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ByaXRlcyBzaG91bGQgYmUgZG93bmxvYWRlZCBhZnRlciB0aGV5J3JlIHJldHJpZXZlZCBvciBub3QuXHJcbiAqIFxyXG4gKiBAcmV0dXJucyB7QXJyYXk8U3ByaXRlPn0gUmV0dXJucyB0aGUgaW5kaXZpZHVhbCBzcHJpdGVzIGZyb20gdGhlIHNwcml0ZXNoZWV0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNwcml0ZXNoZWV0VG9TcHJpdGVzKHNwcml0ZXNoZWV0OiBIVE1MSW1hZ2VFbGVtZW50LCBzcHJpdGVXaWR0aDogbnVtYmVyLCBzcHJpdGVIZWlnaHQ6IG51bWJlciwgb3B0aW9uczogU3ByaXRlc2hlZXRUb1Nwcml0ZXNPcHRpb25zID0ge30pOiBBcnJheTxTcHJpdGU+IHtcclxuICBjb25zdCBuYW1lID0gb3B0aW9ucy5uYW1lID8gb3B0aW9ucy5uYW1lIDogJ3Nwcml0ZSc7XHJcblxyXG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuXHJcbiAgLy8gSWYgdGhlIGBhdGxhc2AgaXMgbm90IGEgYEhUTUxJbWFnZUVsZW1lbnRgIHRoZW4gd2UgdGhyb3cgYW4gZXJyb3IgYXMgd2Ugbm9cclxuICAvLyBsb25nZXIgaGFuZGxlIGxvYWRpbmcgaW4gdGhlIHBhcnNlIG1ldGhvZHMuXHJcbiAgaWYgKHNwcml0ZXNoZWV0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCA9PT0gZmFsc2UpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwcml0ZXNoZWV0IHByb3ZpZGVkIGlzIG5vdCBhIGBIVE1MSW1hZ2VFbGVtZW50YC4gSWYgeW91IG5lZWQgdG8gbG9hZCB0aGUgYXRsYXMgZmlyc3QsIHVzZSB0aGUgbG9hZGVyIG1ldGhvZHMgYmVmb3JlIHBhc3NpbmcgaXQgdG8gdGhlIHBhcnNlci4nKTtcclxuICB9XHJcblxyXG4gIGNhbnZhcy53aWR0aCA9IHNwcml0ZVdpZHRoO1xyXG4gIGNhbnZhcy5oZWlnaHQgPSBzcHJpdGVIZWlnaHQ7XHJcblxyXG4gIC8vIFdlIG5lZWQgdG8ga25vdyBob3cgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIGltYWdlcyB3ZSBuZWVkIHRvIGRvd25sb2FkLlxyXG4gIC8vIFRoaXMgb25seSB3b3JrcyBpZiBhbGwgb2YgdGhlIGluZGl2aWR1YWwgc3ByaXRlcyBpbiB0aGUgc3ByaXRlc2hlZXQgYXJlXHJcbiAgLy8gdGhlIHNhbWUgd2lkdGggYW5kIGhlaWdodC5cclxuICBsZXQgY29scyA9IE1hdGguZmxvb3Ioc3ByaXRlc2hlZXQud2lkdGggLyBzcHJpdGVXaWR0aCk7XHJcbiAgbGV0IHJvd3MgPSBNYXRoLmZsb29yKHNwcml0ZXNoZWV0LmhlaWdodCAvIHNwcml0ZUhlaWdodCk7XHJcblxyXG4gIGxldCBsb2NYID0gMDtcclxuICBsZXQgbG9jWSA9IDA7XHJcbiAgbGV0IGNvdW50ZXIgPSAxO1xyXG5cclxuICBjb25zdCBzcHJpdGVzOiBBcnJheTxTcHJpdGU+ID0gW107XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7ICsraikge1xyXG4gICAgICAvLyBEcmF3IHRoZSBwb3J0aW9uIG9mIHRoZSBzcHJpdGVzaGVldCB3aGVyZSB0aGUgY3VycmVudCBzcHJpdGUgc2hvdWxkIGJlIHRvIHRoZSBjYW52YXMuXHJcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3ByaXRlc2hlZXQsIGxvY1gsIGxvY1ksIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQsIDAsIDAsIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQpO1xyXG5cclxuICAgICAgbG9jWCArPSBzcHJpdGVXaWR0aDtcclxuXHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgc3ByaXRlIG9iamVjdCBhbmQgYWRkIGl0IHRvIHRoZSBgc3ByaXRlc2AgQXJyYXkuXHJcbiAgICAgIGNvbnN0IHNwcml0ZUltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgIHNwcml0ZUltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpLnJlcGxhY2UoJ2ltYWdlL3BuZycsICdpbWFnZS9vY3RldC1zdHJlYW0nKTtcclxuXHJcbiAgICAgIGNvbnN0IHNwcml0ZTogU3ByaXRlID0ge1xyXG4gICAgICAgIG5hbWU6IGAke25hbWV9XyR7Y291bnRlcn1gLFxyXG4gICAgICAgIHg6IGxvY1gsXHJcbiAgICAgICAgeTogbG9jWSxcclxuICAgICAgICB3aWR0aDogc3ByaXRlV2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBzcHJpdGVIZWlnaHQsXHJcbiAgICAgICAgaXNSb3RhdGVkOiBmYWxzZSxcclxuICAgICAgICBpbWFnZTogc3ByaXRlSW1hZ2UsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzcHJpdGVzLnB1c2goc3ByaXRlKTtcclxuICAgICAgY291bnRlcisrO1xyXG4gICAgfVxyXG5cclxuICAgIGxvY1kgKz0gc3ByaXRlSGVpZ2h0O1xyXG4gICAgbG9jWCA9IDA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3ByaXRlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGluZGl2aWR1YWwgc3ByaXRlcyBvZiBhbiBhdGxhcy4gQW4gYXRsYXMgaXMgYSBzcHJpdGVzaGVldCBpbiB3aGljaFxyXG4gKiB0aGUgc3ByaXRlcyBhcmUgaW4gZGlmZmVyZW50IG9yZGVycyBhbmQgc2l6ZXMgd2l0aCB0aGVpciBwb3NpdGlvbnMgZGVmaW5lZCBieVxyXG4gKiBhIEpTT04gb3IgWE1MIGZpbGUuXHJcbiAqIFxyXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IHNwcml0ZXNoZWV0IFRoZSB0ZXh0dXJlIGF0bGFzIGltYWdlIGVsZW1lbnQgdG8gcGFyc2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fFhNTERvY3VtZW50fSBkZWZpbml0aW9uIFRoZSBYTUwgb3IgSlNPTiBmaWxlIHRoYXQgZGVmaW5lcyB0aGUgbG9jYXRpb25zIGFuZCBzaXplcyBvZiB0aGUgaW5kaXZpZHVhbCBzcHJpdGVzIGluIHRoZSBzcHJpdGVzaGVldC5cclxuICogQHBhcmFtIHtBdGxhc1RvU3ByaXRlc09wdGlvbnN9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuanNvblByb3BlcnR5UGF0aD0nZnJhbWVzLiQuZnJhbWUnXSBUaGUgcGF0aCB0byB0aGUgc3ByaXRlIGRldGFpbHMgaW4gdGhlIEpTT04gaWYgYSBKU09OIGRlZmluaXRpb24gaXMgcHJvdmlkZWQuIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGBBdGxhc1RvU3ByaXRlc09wdGlvbnNgIGZvciBhIG1vcmUgaW4tZGVwdGggZXhhbXBsZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNyb3NzT3JpZ2luPScnXSBTZXRzIHRoZSBjcm9zcy1vcmlnaW4gcHJvcGVydHkgb2YgdGhlIGF0bGFzIGlmIHRoZSBhdGxhcyBpcyBob3N0ZWQgZWxzZXdoZXJlLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRvd25sb2FkPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ByaXRlcyBzaG91bGQgYmUgZG93bmxvYWRlZCBhZnRlciB0aGV5J3JlIHJldHJpZXZlZCBvciBub3QuXHJcbiAqIFxyXG4gKiBAcmV0dXJucyB7QXJyYXk8U3ByaXRlPn0gUmV0dXJucyB0aGUgaW5kaXZpZHVhbCBzcHJpdGVzIGZyb20gdGhlIGF0bGFzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGF0bGFzVG9TcHJpdGVzKHNwcml0ZXNoZWV0OiBIVE1MSW1hZ2VFbGVtZW50LCBkZWZpbml0aW9uOiAoT2JqZWN0IHwgWE1MRG9jdW1lbnQpLCBvcHRpb25zOiBBdGxhc1RvU3ByaXRlc09wdGlvbnMgPSB7fSk6IEFycmF5PFNwcml0ZT4ge1xyXG4gIGNvbnN0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuXHJcbiAgLy8gSWYgdGhlIGBhdGxhc2AgaXMgbm90IGEgYEhUTUxJbWFnZUVsZW1lbnRgIHRoZW4gd2UgdGhyb3cgYW4gZXJyb3IgYXMgd2Ugbm9cclxuICAvLyBsb25nZXIgaGFuZGxlIGxvYWRpbmcgaW4gdGhlIHBhcnNlIG1ldGhvZHMuXHJcbiAgaWYgKHNwcml0ZXNoZWV0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCA9PT0gZmFsc2UpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGF0bGFzIHByb3ZpZGVkIGlzIG5vdCBhIGBIVE1MSW1hZ2VFbGVtZW50YC4gSWYgeW91IG5lZWQgdG8gbG9hZCB0aGUgYXRsYXMgZmlyc3QsIHVzZSB0aGUgbG9hZGVyIG1ldGhvZHMgYmVmb3JlIHBhc3NpbmcgaXQgdG8gdGhlIHBhcnNlci4nKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNwcml0ZXM6IEFycmF5PFNwcml0ZT4gPSBbXTtcclxuXHJcbiAgLy8gRmluZCBvdXQgd2hhdCB0eXBlIG9mIGRhdGEgd2FzIHByb3ZpZGVkLCBYTUwgb3IgSlNPTi4gSWYgaXQncyBuZWl0aGVyIG9mXHJcbiAgLy8gdGhvc2UgdGhlbiB3ZSB0aHJvdyBhbiBlcnJvci5cclxuICBsZXQgZGF0YVR5cGU7XHJcbiAgaWYgKGRlZmluaXRpb24gaW5zdGFuY2VvZiBYTUxEb2N1bWVudCkgZGF0YVR5cGUgPSAneG1sJztcclxuICBlbHNlIGlmIChkZWZpbml0aW9uIGluc3RhbmNlb2YgT2JqZWN0KSBkYXRhVHlwZSA9ICdqc29uJztcclxuICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhlIGRlZmluaXRpb24gbXVzdCBiZSBlaXRoZXIgWE1MIG9yIEpTT04nKTtcclxuXHJcbiAgc3dpdGNoIChkYXRhVHlwZSkge1xyXG4gICAgY2FzZSAneG1sJzpcclxuICAgICAgY29uc3QgeG1sRGVmaW5pdGlvbiA9IGRlZmluaXRpb24gYXMgWE1MRG9jdW1lbnQ7XHJcblxyXG4gICAgICAvLyBXZSB3YW50IHRvIGdldCBhbGwgbm9kZXMgdGhhdCBoYXZlIGEgYG5hbWVgLCBgeGAsIGFuZCBgeWAsIGB3aWR0aGAsIGFuZCBcclxuICAgICAgLy8gYGhlaWdodGAgYXR0cmlidXRlcy5cclxuICAgICAgbGV0IHNwcml0ZUVudHJpZXM6IE5vZGVMaXN0T2Y8QXRsYXNTcHJpdGVEYXRhPiA9IHhtbERlZmluaXRpb24ucXVlcnlTZWxlY3RvckFsbCgnW3hdW3ldW3dpZHRoXVtoZWlnaHRdJyk7XHJcblxyXG4gICAgICAvLyBJZiB0aGUgYWJvdmUgaXMgZW1wdHkgdGhlbiBtYXliZSB0aGUgYGhlaWdodGAgYW5kIGB3aWR0aGAgYXR0cmlidXRlcyBhcmVcclxuICAgICAgLy8gYWN0dWFsbHkgYHdgIG9yIGBoYCBzbyB3ZSBjaGVjayBmb3IgdGhhdC5cclxuICAgICAgaWYgKHNwcml0ZUVudHJpZXMubGVuZ3RoID09PSAwKSBzcHJpdGVFbnRyaWVzID0geG1sRGVmaW5pdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdbeF1beV1bd11baF0nKTtcclxuXHJcbiAgICAgIC8vIElmIGJvdGggb2YgdGhvc2UgYXJlIHN0aWxsIGVtcHR5IHRoZW4gd2UgY2FuJ3QgcHJvY2VlZC4gTWF5YmUgaW4gbGF0ZXJcclxuICAgICAgLy8gdXBkYXRlcyB3ZSdsbCBtYWtlIHRoaXMgbW9yZSBmbGV4aWJsZSBidXQgSSBoYXZlbid0IGZvdW5kIGNhc2VzIGZvciBpdFxyXG4gICAgICAvLyB5ZXQgaW4gdGhlIGF0bGFzJyBJJ3ZlIHVzZWQuXHJcbiAgICAgIGlmIChzcHJpdGVFbnRyaWVzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhbnkgcm93cyB3aXRoIGB4YCwgYHlgLCBgd2lkdGhgLCBvciBgaGVpZ2h0YCBhdHRyaWJ1dGVzJyk7XHJcblxyXG4gICAgICBzcHJpdGVFbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xyXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIHNwcml0ZSdzIHdpZHRoIGFuZCBoZWlnaHQgYW5kIHNlZSBpZiBhIGByb3RhdGVkYCBhdHRyaWJ1dGUgZXhpc3RzLlxyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQoZW50cnkuZ2V0QXR0cmlidXRlKCd3aWR0aCcpISB8fCBlbnRyeS5nZXRBdHRyaWJ1dGUoJ3cnKSEpO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBhcnNlSW50KGVudHJ5LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykhIHx8IGVudHJ5LmdldEF0dHJpYnV0ZSgnaCcpISk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzUm90YXRlZCA9IEJvb2xlYW4oZW50cnkuZ2V0QXR0cmlidXRlKCdyb3RhdGVkJykpO1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZVdpZHRoID0gaXNSb3RhdGVkID8gaGVpZ2h0IDogd2lkdGg7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlSGVpZ2h0ID0gaXNSb3RhdGVkID8gd2lkdGggOiBoZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICghc3ByaXRlV2lkdGggfHwgIXNwcml0ZUhlaWdodCkgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhIHdpZHRoIG9yIGhlaWdodCBmb3IgdGhlIHNwcml0ZSBlbnRyaWVzJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHggPSBwYXJzZUludChlbnRyeS5nZXRBdHRyaWJ1dGUoJ3gnKSEpO1xyXG4gICAgICAgIGNvbnN0IHkgPSBwYXJzZUludChlbnRyeS5nZXRBdHRyaWJ1dGUoJ3knKSEpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGNhbnZhcyB0byB0aGUgc2l6ZSBvZiB0aGUgc3ByaXRlIGFuZCB0aGVuIGRyYXcgdGhlIHNwcml0ZSBvbnRvIHRoZSBjYW52YXMuXHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gc3ByaXRlV2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHNwcml0ZUhlaWdodDtcclxuXHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShzcHJpdGVzaGVldCwgeCwgeSwgc3ByaXRlV2lkdGgsIHNwcml0ZUhlaWdodCwgMCwgMCwgc3ByaXRlV2lkdGgsIHNwcml0ZUhlaWdodCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNwcml0ZUltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgc3ByaXRlSW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykucmVwbGFjZSgnaW1hZ2UvcG5nJywgJ2ltYWdlL29jdGV0LXN0cmVhbScpO1xyXG5cclxuICAgICAgICAvLyBMYXN0bHkgd2UgY3JlYXRlIHRoZSB0aGUgU3ByaXRlIG9iamVjdCBhbmQgYWRkIGl0IHRvIGBzcHJpdGVzYC5cclxuICAgICAgICBjb25zdCBzcHJpdGU6IFNwcml0ZSA9IHtcclxuICAgICAgICAgIG5hbWU6IGVudHJ5LmdldEF0dHJpYnV0ZSgnbmFtZScpISxcclxuICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgd2lkdGg6IHNwcml0ZVdpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiBzcHJpdGVIZWlnaHQsXHJcbiAgICAgICAgICBpc1JvdGF0ZWQ6IGlzUm90YXRlZCxcclxuICAgICAgICAgIGltYWdlOiBzcHJpdGVJbWFnZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHNwcml0ZXMucHVzaChzcHJpdGUpO1xyXG4gICAgICB9KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdqc29uJzpcclxuICAgICAgY29uc3QganNvbkRlZmluaXRpb246IGFueSA9IGRlZmluaXRpb24gYXMgT2JqZWN0O1xyXG5cclxuICAgICAgLy8gSWYgYSBwcm9wZXJ0eSBwYXRoIGFzIHByb3ZpZGVkIGluIHRoZSBvcHRpb25zIHRoZW4gd2UgdXNlIHRoYXQgb3RoZXJ3aXNlIHdlIHVzZSB0aGUgZGVmYXVsdCBvbmUuXHJcbiAgICAgIGNvbnN0IGpzb25Qcm9wZXJ0eVBhdGggPSBvcHRpb25zLmpzb25Qcm9wZXJ0eVBhdGggPyBvcHRpb25zLmpzb25Qcm9wZXJ0eVBhdGggOiAnZnJhbWVzLiQuZnJhbWUnO1xyXG4gICAgICAvLyBTcGxpdCB0aGUgcHJvcGVydHkgcGF0aCBvbiBwZXJpb2RzIHNvIHRoYXQgd2UgY2FuIHVzZSBpdCB0byBuYXZpZ2F0ZSB0aGUgb2JqZWN0LlxyXG4gICAgICBjb25zdCBwcm9wZXJ0eVBhdGhTcGxpdCA9IGpzb25Qcm9wZXJ0eVBhdGguc3BsaXQoJy4nKTtcclxuXHJcbiAgICAgIC8vIFdlIG5lZWQgdG8ga25vdyB0aGUgaW5kZXggb2YgdGhlICckJyBjaGFyYWN0ZXIgd2hpY2ggZGVub3RlcyB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGVcclxuICAgICAgLy8gaW5kaXZpZHVhbCBzcHJpdGVcclxuICAgICAgY29uc3QgaW5kZXhPZlNwcml0ZSA9IHByb3BlcnR5UGF0aFNwbGl0LmluZGV4T2YoJyQnKTtcclxuICAgICAgY29uc3QgcHJvcGVydHlQYXRoQmVmb3JlU3ByaXRlID0gcHJvcGVydHlQYXRoU3BsaXQuc3BsaWNlKDAsIGluZGV4T2ZTcHJpdGUpO1xyXG5cclxuICAgICAgLy8gTm93IHdlIGdldCB0aGUgcGFydCBvZiB0aGUgYXJyYXkgdXAgdW50aWwgYHByb3BlcnR5UGF0aEJlZm9yZVNwcml0ZWAgc28gdGhhdCB3ZSBjYW4gZ2V0IHRoZVxyXG4gICAgICAvLyBwYXJ0cyBvZiB0aGUgb2JqZWN0IHRoYXQgd2UgY2FuIGl0ZXJhdGUuIFxyXG4gICAgICBsZXQgYWxsU3ByaXRlc0luSlNPTiA9IGpzb25EZWZpbml0aW9uO1xyXG4gICAgICBwcm9wZXJ0eVBhdGhCZWZvcmVTcHJpdGUuZm9yRWFjaChwcm9wZXJ0eSA9PiBhbGxTcHJpdGVzSW5KU09OID0gYWxsU3ByaXRlc0luSlNPTltwcm9wZXJ0eV0pO1xyXG5cclxuICAgICAgLy8gR2V0IHRoZSBsYXN0IHBhcnQgb2YgdGhlIHByb3BlcnR5UGF0aFNwbGl0IHdpdGhvdXQgdGhlICQgZWxlbWVudC5cclxuICAgICAgY29uc3QgcHJvcGVydHlEZXRhaWxzUGF0aCA9IHByb3BlcnR5UGF0aFNwbGl0LnNsaWNlKDEpO1xyXG5cclxuICAgICAgZm9yIChsZXQgc3ByaXRlRGV0YWlscyBpbiBhbGxTcHJpdGVzSW5KU09OKSB7XHJcbiAgICAgICAgbGV0IHNwcml0ZUVudHJ5OiBhbnkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFsbFNwcml0ZXNJbkpTT05bc3ByaXRlRGV0YWlsc10pKTtcclxuXHJcbiAgICAgICAgLy8gRm9yIGVhY2ggc3ByaXRlIGluIHRoZSBKU09OIHdlIGhhdmUgdG8gZmluaXNoIHRoZSBvYmplY3QgbG9va3VwIHdpdGggdGhlIHJlbWFpbmluZyB2YWx1ZXNcclxuICAgICAgICAvLyBvZiB0aGUgYHByb3BlcnR5RGV0YWlsc1BhdGhgLlxyXG4gICAgICAgIHByb3BlcnR5RGV0YWlsc1BhdGguZm9yRWFjaChwcm9wZXJ0eSA9PiBzcHJpdGVFbnRyeSA9IHNwcml0ZUVudHJ5W3Byb3BlcnR5XSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVudHJ5OiBBdGxhc1Nwcml0ZURhdGEgPSBzcHJpdGVFbnRyeTtcclxuXHJcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgc3ByaXRlJ3Mgd2lkdGggYW5kIGhlaWdodCBhbmQgc2VlIGlmIHdlIG5lZWQgdG8gcm90YXRlIGl0LlxyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gZW50cnkud2lkdGggfHwgZW50cnkudztcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5oZWlnaHQgfHwgZW50cnkuaDtcclxuICAgICAgICBjb25zdCBpc1JvdGF0ZWQgPSBlbnRyeS5yb3RhdGVkIHx8IGFsbFNwcml0ZXNJbkpTT05bc3ByaXRlRGV0YWlsc10ucm90YXRlZCB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3ByaXRlV2lkdGggPSBpc1JvdGF0ZWQgPyBoZWlnaHQgOiB3aWR0aDtcclxuICAgICAgICBjb25zdCBzcHJpdGVIZWlnaHQgPSBpc1JvdGF0ZWQgPyB3aWR0aCA6IGhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKCFzcHJpdGVXaWR0aCB8fCAhc3ByaXRlSGVpZ2h0KSB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGEgd2lkdGggb3IgaGVpZ2h0IGZvciB0aGUgc3ByaXRlIGVudHJpZXMnKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBjYW52YXMgdG8gdGhlIHNpemUgb2YgdGhlIHNwcml0ZS5cclxuICAgICAgICBjYW52YXMud2lkdGggPSBzcHJpdGVXaWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gc3ByaXRlSGVpZ2h0O1xyXG5cclxuICAgICAgICBjdHguZHJhd0ltYWdlKHNwcml0ZXNoZWV0LCBlbnRyeS54LCBlbnRyeS55LCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0LCAwLCAwLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3ByaXRlSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBzcHJpdGVJbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKS5yZXBsYWNlKCdpbWFnZS9wbmcnLCAnaW1hZ2Uvb2N0ZXQtc3RyZWFtJyk7XHJcblxyXG4gICAgICAgIC8vIExhc3RseSB3ZSBjcmVhdGUgdGhlIFNwcml0ZSBvYmplY3QgYW5kIGFkZCBpdCB0byBgc3ByaXRlc2AuXHJcbiAgICAgICAgY29uc3Qgc3ByaXRlOiBTcHJpdGUgPSB7XHJcbiAgICAgICAgICBuYW1lOiBlbnRyeS5uYW1lIHx8IHNwcml0ZURldGFpbHMsXHJcbiAgICAgICAgICB4OiBlbnRyeS54LFxyXG4gICAgICAgICAgeTogZW50cnkueSxcclxuICAgICAgICAgIHdpZHRoOiBzcHJpdGVXaWR0aCxcclxuICAgICAgICAgIGhlaWdodDogc3ByaXRlSGVpZ2h0LFxyXG4gICAgICAgICAgaXNSb3RhdGVkOiBpc1JvdGF0ZWQsXHJcbiAgICAgICAgICBpbWFnZTogc3ByaXRlSW1hZ2UsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBzcHJpdGVzLnB1c2goc3ByaXRlKTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICB9XHJcblxyXG4gIHJldHVybiBzcHJpdGVzO1xyXG59Il19