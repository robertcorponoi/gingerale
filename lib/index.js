'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spritesheetToSprites = spritesheetToSprites;
exports.atlasToSprites = atlasToSprites;
Object.defineProperty(exports, "loadSpritesheet", {
  enumerable: true,
  get: function get() {
    return _loaders.loadSpritesheet;
  }
});
Object.defineProperty(exports, "loadXML", {
  enumerable: true,
  get: function get() {
    return _loaders.loadXML;
  }
});
Object.defineProperty(exports, "loadJSON", {
  enumerable: true,
  get: function get() {
    return _loaders.loadJSON;
  }
});

var _utils = require("./utils");

var _loaders = require("./loaders");

/**
 * Returns the individual sprites of a uniform spritesheet. A uniform spritesheet
 * is a spritesheet in which all of the individual sprites are the same size and
 * in a uniform fashion. Even if you have a uniform spritesheet but it has a XML
 * or JSON definition file, use `atlasToSprites` instead.
 * 
 * @param {HTMLImageElement} spritesheet The spritesheet image element to parse.
 * @param {number} spriteWidth The width of every individual sprite in the spritesheet.
 * @param {number} spriteHeight The height of every individual sprite in the spritesheet.
 * @param {SpritesheetToSpritesOptions} [options] The options that can be passed to this method.
 * @param {string} [options.name='sprite'] Sets the name of the individual sprites and used as the name for the file if downloaded.
 * @param {string} [options.crossOrigin=''] Sets the cross-origin property of the spritesheet if the spritesheet is hosted elsewhere.
 * @param {boolean} [options.download=false] Indicates whether the sprites should be downloaded after they're retrieved or not.
 * 
 * @returns {Array<Sprite>} Returns the individual sprites from the spritesheet.
 */
function spritesheetToSprites(spritesheet, spriteWidth, spriteHeight) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var name = options.name ? options.name : 'sprite';
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d'); // If the `atlas` is not a `HTMLImageElement` then we throw an error as we no
  // longer handle loading in the parse methods.

  if (spritesheet instanceof HTMLImageElement === false) {
    throw new Error('The atlas provided is not a `HTMLImageElement`. If you need to load the atlas first, use the loader methods before passing it to the parser.');
  }

  canvas.width = spriteWidth;
  canvas.height = spriteHeight; // We need to know how many rows and columns of images we need to download.
  // This only works if all of the individual sprites in the spritesheet are
  // the same width and height.

  var cols = Math.floor(spritesheet.width / spriteWidth);
  var rows = Math.floor(spritesheet.height / spriteHeight);
  var locX = 0;
  var locY = 0;
  var counter = 1;
  var sprites = [];

  for (var i = 0; i < rows; ++i) {
    for (var j = 0; j < cols; ++j) {
      // Draw the portion of the spritesheet where the current sprite should be to the canvas.
      ctx.drawImage(spritesheet, locX, locY, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
      locX += spriteWidth;
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Create the sprite object and add it to the `sprites` Array.

      var spriteImage = new Image();
      spriteImage.src = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream');
      var sprite = {
        name: "".concat(name, "_").concat(counter),
        x: locX,
        y: locY,
        width: spriteWidth,
        height: spriteHeight,
        isRotated: false,
        image: spriteImage
      };
      sprites.push(sprite);
      counter++;
    }

    locY += spriteHeight;
    locX = 0;
  }

  if (options.download) (0, _utils.downloadSprites)(sprites);
  return sprites;
}
/**
 * Returns the individual sprites of an atlas. An atlas is a spritesheet in which
 * the sprites are in different orders and sizes with their positions defined by
 * a JSON or XML file.
 * 
 * @param {HTMLImageElement} spritesheet The texture atlas image element to parse.
 * @param {Object|XMLDocument} definition The XML or JSON file that defines the locations and sizes of the individual sprites in the spritesheet.
 * @param {AtlasToSpritesOptions} [options]
 * @param {string} [options.jsonPropertyPath='frames.$.frame'] The path to the sprite details in the JSON if a JSON definition is provided. See the documentation for the `AtlasToSpritesOptions` for a more in-depth example.
 * @param {string} [options.crossOrigin=''] Sets the cross-origin property of the atlas if the atlas is hosted elsewhere.
 * @param {boolean} [options.download=false] Indicates whether the sprites should be downloaded after they're retrieved or not.
 * 
 * @returns {Array<Sprite>} Returns the individual sprites from the atlas.
 */


function atlasToSprites(spritesheet, definition) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d'); // If the `atlas` is not a `HTMLImageElement` then we throw an error as we no
  // longer handle loading in the parse methods.

  if (spritesheet instanceof HTMLImageElement === false) {
    throw new Error('The atlas provided is not a `HTMLImageElement`. If you need to load the atlas first, use the loader methods before passing it to the parser.');
  }

  var sprites = []; // Find out what type of data was provided, XML or JSON. If it's neither of
  // those then we throw an error.

  var dataType;
  if (definition instanceof XMLDocument) dataType = 'xml';else if (definition instanceof Object) dataType = 'json';else throw new Error('The definition must be either XML or JSON');

  switch (dataType) {
    case 'xml':
      var xmlDefinition = definition; // We want to get all nodes that have a `name`, `x`, and `y`, `width`, and 
      // `height` attributes.

      var spriteEntries = xmlDefinition.querySelectorAll('[x][y][width][height]'); // If the above is empty then maybe the `height` and `width` attributes are
      // actually `w` or `h` so we check for that.

      if (spriteEntries.length === 0) spriteEntries = xmlDefinition.querySelectorAll('[x][y][w][h]'); // If both of those are still empty then we can't proceed. Maybe in later
      // updates we'll make this more flexible but I haven't found cases for it
      // yet in the atlas' I've used.

      if (spriteEntries.length === 0) throw new Error('Could not find any rows with `x`, `y`, `width`, or `height` attributes');
      spriteEntries.forEach(function (entry) {
        // Keep track of the sprite's width and height and see if a `rotated` attribute exists.
        var width = parseInt(entry.getAttribute('width') || entry.getAttribute('w'));
        var height = parseInt(entry.getAttribute('height') || entry.getAttribute('h'));
        var isRotated = Boolean(entry.getAttribute('rotated'));
        var spriteWidth = isRotated ? height : width;
        var spriteHeight = isRotated ? width : height;
        if (!spriteWidth || !spriteHeight) throw new Error('Could not find a width or height for the sprite entries');
        var x = parseInt(entry.getAttribute('x'));
        var y = parseInt(entry.getAttribute('y')); // Set the canvas to the size of the sprite and then draw the sprite onto the canvas.

        canvas.width = spriteWidth;
        canvas.height = spriteHeight;
        ctx.drawImage(spritesheet, x, y, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
        var spriteImage = new Image();
        spriteImage.src = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream'); // Lastly we create the the Sprite object and add it to `sprites`.

        var sprite = {
          name: entry.getAttribute('name'),
          x: x,
          y: y,
          width: spriteWidth,
          height: spriteHeight,
          isRotated: isRotated,
          image: spriteImage
        };
        sprites.push(sprite);
      });
      break;

    case 'json':
      var jsonDefinition = definition; // If a property path as provided in the options then we use that otherwise we use the default one.

      var jsonPropertyPath = options.jsonPropertyPath ? options.jsonPropertyPath : 'frames.$.frame'; // Split the property path on periods so that we can use it to navigate the object.

      var propertyPathSplit = jsonPropertyPath.split('.'); // We need to know the index of the '$' character which denotes the property that contains the
      // individual sprite

      var indexOfSprite = propertyPathSplit.indexOf('$');
      var propertyPathBeforeSprite = propertyPathSplit.splice(0, indexOfSprite); // Now we get the part of the array up until `propertyPathBeforeSprite` so that we can get the
      // parts of the object that we can iterate. 

      var allSpritesInJSON = jsonDefinition;
      propertyPathBeforeSprite.forEach(function (property) {
        return allSpritesInJSON = allSpritesInJSON[property];
      }); // Get the last part of the propertyPathSplit without the $ element.

      var propertyDetailsPath = propertyPathSplit.slice(1);

      var _loop = function _loop(spriteDetails) {
        var spriteEntry = JSON.parse(JSON.stringify(allSpritesInJSON[spriteDetails])); // For each sprite in the JSON we have to finish the object lookup with the remaining values
        // of the `propertyDetailsPath`.

        propertyDetailsPath.forEach(function (property) {
          return spriteEntry = spriteEntry[property];
        });
        var entry = spriteEntry; // Keep track of the sprite's width and height and see if we need to rotate it.

        var width = entry.width || entry.w;
        var height = entry.height || entry.h;
        var isRotated = entry.rotated || allSpritesInJSON[spriteDetails].rotated || false;
        var spriteWidth = isRotated ? height : width;
        var spriteHeight = isRotated ? width : height;
        if (!spriteWidth || !spriteHeight) throw new Error('Could not find a width or height for the sprite entries'); // Set the canvas to the size of the sprite.

        canvas.width = spriteWidth;
        canvas.height = spriteHeight;
        ctx.drawImage(spritesheet, entry.x, entry.y, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
        var spriteImage = new Image();
        spriteImage.src = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream'); // Lastly we create the Sprite object and add it to `sprites`.

        var sprite = {
          name: entry.name || spriteDetails,
          x: entry.x,
          y: entry.y,
          width: spriteWidth,
          height: spriteHeight,
          isRotated: isRotated,
          image: spriteImage
        };
        sprites.push(sprite);
      };

      for (var spriteDetails in allSpritesInJSON) {
        _loop(spriteDetails);
      }

      break;
  }

  if (options.download) (0, _utils.downloadSprites)(sprites);
  return sprites;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJzcHJpdGVzaGVldFRvU3ByaXRlcyIsInNwcml0ZXNoZWV0Iiwic3ByaXRlV2lkdGgiLCJzcHJpdGVIZWlnaHQiLCJvcHRpb25zIiwibmFtZSIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJIVE1MSW1hZ2VFbGVtZW50IiwiRXJyb3IiLCJ3aWR0aCIsImhlaWdodCIsImNvbHMiLCJNYXRoIiwiZmxvb3IiLCJyb3dzIiwibG9jWCIsImxvY1kiLCJjb3VudGVyIiwic3ByaXRlcyIsImkiLCJqIiwiZHJhd0ltYWdlIiwiY2xlYXJSZWN0Iiwic3ByaXRlSW1hZ2UiLCJJbWFnZSIsInNyYyIsInRvRGF0YVVSTCIsInJlcGxhY2UiLCJzcHJpdGUiLCJ4IiwieSIsImlzUm90YXRlZCIsImltYWdlIiwicHVzaCIsImRvd25sb2FkIiwiYXRsYXNUb1Nwcml0ZXMiLCJkZWZpbml0aW9uIiwiZGF0YVR5cGUiLCJYTUxEb2N1bWVudCIsIk9iamVjdCIsInhtbERlZmluaXRpb24iLCJzcHJpdGVFbnRyaWVzIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsImZvckVhY2giLCJlbnRyeSIsInBhcnNlSW50IiwiZ2V0QXR0cmlidXRlIiwiQm9vbGVhbiIsImpzb25EZWZpbml0aW9uIiwianNvblByb3BlcnR5UGF0aCIsInByb3BlcnR5UGF0aFNwbGl0Iiwic3BsaXQiLCJpbmRleE9mU3ByaXRlIiwiaW5kZXhPZiIsInByb3BlcnR5UGF0aEJlZm9yZVNwcml0ZSIsInNwbGljZSIsImFsbFNwcml0ZXNJbkpTT04iLCJwcm9wZXJ0eSIsInByb3BlcnR5RGV0YWlsc1BhdGgiLCJzbGljZSIsInNwcml0ZURldGFpbHMiLCJzcHJpdGVFbnRyeSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInciLCJoIiwicm90YXRlZCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7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NEJBQWdCaEIsT0FBaEI7QUFFdEIsU0FBT0EsT0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL2ludGVyZmFjZXMvc3ByaXRlJztcclxuaW1wb3J0IHsgQXRsYXNTcHJpdGVEYXRhIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2F0bGFzX3Nwcml0ZV9kYXRhJztcclxuXHJcbmltcG9ydCB7IEF0bGFzVG9TcHJpdGVzT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucy9hdGxhc190b19zcHJpdGVzX29wdGlvbnMnO1xyXG5pbXBvcnQgeyBTcHJpdGVzaGVldFRvU3ByaXRlc09wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMvc3ByaXRlc2hlZXRfdG9fc3ByaXRlc19vcHRpb25zJztcclxuXHJcbmltcG9ydCB7IGRvd25sb2FkU3ByaXRlcyB9IGZyb20gJy4vdXRpbHMnO1xyXG5pbXBvcnQgeyBsb2FkU3ByaXRlc2hlZXQsIGxvYWRYTUwsIGxvYWRKU09OIH0gZnJvbSAnLi9sb2FkZXJzJztcclxuXHJcbmV4cG9ydCB7XHJcbiAgbG9hZFhNTCxcclxuICBsb2FkSlNPTixcclxuICBsb2FkU3ByaXRlc2hlZXQsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIHNwcml0ZXMgb2YgYSB1bmlmb3JtIHNwcml0ZXNoZWV0LiBBIHVuaWZvcm0gc3ByaXRlc2hlZXRcclxuICogaXMgYSBzcHJpdGVzaGVldCBpbiB3aGljaCBhbGwgb2YgdGhlIGluZGl2aWR1YWwgc3ByaXRlcyBhcmUgdGhlIHNhbWUgc2l6ZSBhbmRcclxuICogaW4gYSB1bmlmb3JtIGZhc2hpb24uIEV2ZW4gaWYgeW91IGhhdmUgYSB1bmlmb3JtIHNwcml0ZXNoZWV0IGJ1dCBpdCBoYXMgYSBYTUxcclxuICogb3IgSlNPTiBkZWZpbml0aW9uIGZpbGUsIHVzZSBgYXRsYXNUb1Nwcml0ZXNgIGluc3RlYWQuXHJcbiAqIFxyXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IHNwcml0ZXNoZWV0IFRoZSBzcHJpdGVzaGVldCBpbWFnZSBlbGVtZW50IHRvIHBhcnNlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3ByaXRlV2lkdGggVGhlIHdpZHRoIG9mIGV2ZXJ5IGluZGl2aWR1YWwgc3ByaXRlIGluIHRoZSBzcHJpdGVzaGVldC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHNwcml0ZUhlaWdodCBUaGUgaGVpZ2h0IG9mIGV2ZXJ5IGluZGl2aWR1YWwgc3ByaXRlIGluIHRoZSBzcHJpdGVzaGVldC5cclxuICogQHBhcmFtIHtTcHJpdGVzaGVldFRvU3ByaXRlc09wdGlvbnN9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lPSdzcHJpdGUnXSBTZXRzIHRoZSBuYW1lIG9mIHRoZSBpbmRpdmlkdWFsIHNwcml0ZXMgYW5kIHVzZWQgYXMgdGhlIG5hbWUgZm9yIHRoZSBmaWxlIGlmIGRvd25sb2FkZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbj0nJ10gU2V0cyB0aGUgY3Jvc3Mtb3JpZ2luIHByb3BlcnR5IG9mIHRoZSBzcHJpdGVzaGVldCBpZiB0aGUgc3ByaXRlc2hlZXQgaXMgaG9zdGVkIGVsc2V3aGVyZS5cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kb3dubG9hZD1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwcml0ZXMgc2hvdWxkIGJlIGRvd25sb2FkZWQgYWZ0ZXIgdGhleSdyZSByZXRyaWV2ZWQgb3Igbm90LlxyXG4gKiBcclxuICogQHJldHVybnMge0FycmF5PFNwcml0ZT59IFJldHVybnMgdGhlIGluZGl2aWR1YWwgc3ByaXRlcyBmcm9tIHRoZSBzcHJpdGVzaGVldC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzcHJpdGVzaGVldFRvU3ByaXRlcyhzcHJpdGVzaGVldDogSFRNTEltYWdlRWxlbWVudCwgc3ByaXRlV2lkdGg6IG51bWJlciwgc3ByaXRlSGVpZ2h0OiBudW1iZXIsIG9wdGlvbnM6IFNwcml0ZXNoZWV0VG9TcHJpdGVzT3B0aW9ucyA9IHt9KTogQXJyYXk8U3ByaXRlPiB7XHJcbiAgY29uc3QgbmFtZSA9IG9wdGlvbnMubmFtZSA/IG9wdGlvbnMubmFtZSA6ICdzcHJpdGUnO1xyXG5cclxuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSE7XHJcblxyXG4gIC8vIElmIHRoZSBgYXRsYXNgIGlzIG5vdCBhIGBIVE1MSW1hZ2VFbGVtZW50YCB0aGVuIHdlIHRocm93IGFuIGVycm9yIGFzIHdlIG5vXHJcbiAgLy8gbG9uZ2VyIGhhbmRsZSBsb2FkaW5nIGluIHRoZSBwYXJzZSBtZXRob2RzLlxyXG4gIGlmIChzcHJpdGVzaGVldCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgPT09IGZhbHNlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhdGxhcyBwcm92aWRlZCBpcyBub3QgYSBgSFRNTEltYWdlRWxlbWVudGAuIElmIHlvdSBuZWVkIHRvIGxvYWQgdGhlIGF0bGFzIGZpcnN0LCB1c2UgdGhlIGxvYWRlciBtZXRob2RzIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSBwYXJzZXIuJyk7XHJcbiAgfVxyXG5cclxuICBjYW52YXMud2lkdGggPSBzcHJpdGVXaWR0aDtcclxuICBjYW52YXMuaGVpZ2h0ID0gc3ByaXRlSGVpZ2h0O1xyXG5cclxuICAvLyBXZSBuZWVkIHRvIGtub3cgaG93IG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiBpbWFnZXMgd2UgbmVlZCB0byBkb3dubG9hZC5cclxuICAvLyBUaGlzIG9ubHkgd29ya3MgaWYgYWxsIG9mIHRoZSBpbmRpdmlkdWFsIHNwcml0ZXMgaW4gdGhlIHNwcml0ZXNoZWV0IGFyZVxyXG4gIC8vIHRoZSBzYW1lIHdpZHRoIGFuZCBoZWlnaHQuXHJcbiAgbGV0IGNvbHMgPSBNYXRoLmZsb29yKHNwcml0ZXNoZWV0LndpZHRoIC8gc3ByaXRlV2lkdGgpO1xyXG4gIGxldCByb3dzID0gTWF0aC5mbG9vcihzcHJpdGVzaGVldC5oZWlnaHQgLyBzcHJpdGVIZWlnaHQpO1xyXG5cclxuICBsZXQgbG9jWCA9IDA7XHJcbiAgbGV0IGxvY1kgPSAwO1xyXG4gIGxldCBjb3VudGVyID0gMTtcclxuXHJcbiAgY29uc3Qgc3ByaXRlczogQXJyYXk8U3ByaXRlPiA9IFtdO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7ICsraSkge1xyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcclxuICAgICAgLy8gRHJhdyB0aGUgcG9ydGlvbiBvZiB0aGUgc3ByaXRlc2hlZXQgd2hlcmUgdGhlIGN1cnJlbnQgc3ByaXRlIHNob3VsZCBiZSB0byB0aGUgY2FudmFzLlxyXG4gICAgICBjdHguZHJhd0ltYWdlKHNwcml0ZXNoZWV0LCBsb2NYLCBsb2NZLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0LCAwLCAwLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0KTtcclxuXHJcbiAgICAgIGxvY1ggKz0gc3ByaXRlV2lkdGg7XHJcblxyXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNwcml0ZSBvYmplY3QgYW5kIGFkZCBpdCB0byB0aGUgYHNwcml0ZXNgIEFycmF5LlxyXG4gICAgICBjb25zdCBzcHJpdGVJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICBzcHJpdGVJbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKS5yZXBsYWNlKCdpbWFnZS9wbmcnLCAnaW1hZ2Uvb2N0ZXQtc3RyZWFtJyk7XHJcblxyXG4gICAgICBjb25zdCBzcHJpdGU6IFNwcml0ZSA9IHtcclxuICAgICAgICBuYW1lOiBgJHtuYW1lfV8ke2NvdW50ZXJ9YCxcclxuICAgICAgICB4OiBsb2NYLFxyXG4gICAgICAgIHk6IGxvY1ksXHJcbiAgICAgICAgd2lkdGg6IHNwcml0ZVdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogc3ByaXRlSGVpZ2h0LFxyXG4gICAgICAgIGlzUm90YXRlZDogZmFsc2UsXHJcbiAgICAgICAgaW1hZ2U6IHNwcml0ZUltYWdlLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc3ByaXRlcy5wdXNoKHNwcml0ZSk7XHJcbiAgICAgIGNvdW50ZXIrKztcclxuICAgIH1cclxuXHJcbiAgICBsb2NZICs9IHNwcml0ZUhlaWdodDtcclxuICAgIGxvY1ggPSAwO1xyXG4gIH1cclxuXHJcbiAgaWYgKG9wdGlvbnMuZG93bmxvYWQpIGRvd25sb2FkU3ByaXRlcyhzcHJpdGVzKTtcclxuXHJcbiAgcmV0dXJuIHNwcml0ZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIHNwcml0ZXMgb2YgYW4gYXRsYXMuIEFuIGF0bGFzIGlzIGEgc3ByaXRlc2hlZXQgaW4gd2hpY2hcclxuICogdGhlIHNwcml0ZXMgYXJlIGluIGRpZmZlcmVudCBvcmRlcnMgYW5kIHNpemVzIHdpdGggdGhlaXIgcG9zaXRpb25zIGRlZmluZWQgYnlcclxuICogYSBKU09OIG9yIFhNTCBmaWxlLlxyXG4gKiBcclxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBzcHJpdGVzaGVldCBUaGUgdGV4dHVyZSBhdGxhcyBpbWFnZSBlbGVtZW50IHRvIHBhcnNlLlxyXG4gKiBAcGFyYW0ge09iamVjdHxYTUxEb2N1bWVudH0gZGVmaW5pdGlvbiBUaGUgWE1MIG9yIEpTT04gZmlsZSB0aGF0IGRlZmluZXMgdGhlIGxvY2F0aW9ucyBhbmQgc2l6ZXMgb2YgdGhlIGluZGl2aWR1YWwgc3ByaXRlcyBpbiB0aGUgc3ByaXRlc2hlZXQuXHJcbiAqIEBwYXJhbSB7QXRsYXNUb1Nwcml0ZXNPcHRpb25zfSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmpzb25Qcm9wZXJ0eVBhdGg9J2ZyYW1lcy4kLmZyYW1lJ10gVGhlIHBhdGggdG8gdGhlIHNwcml0ZSBkZXRhaWxzIGluIHRoZSBKU09OIGlmIGEgSlNPTiBkZWZpbml0aW9uIGlzIHByb3ZpZGVkLiBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgQXRsYXNUb1Nwcml0ZXNPcHRpb25zYCBmb3IgYSBtb3JlIGluLWRlcHRoIGV4YW1wbGUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbj0nJ10gU2V0cyB0aGUgY3Jvc3Mtb3JpZ2luIHByb3BlcnR5IG9mIHRoZSBhdGxhcyBpZiB0aGUgYXRsYXMgaXMgaG9zdGVkIGVsc2V3aGVyZS5cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kb3dubG9hZD1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwcml0ZXMgc2hvdWxkIGJlIGRvd25sb2FkZWQgYWZ0ZXIgdGhleSdyZSByZXRyaWV2ZWQgb3Igbm90LlxyXG4gKiBcclxuICogQHJldHVybnMge0FycmF5PFNwcml0ZT59IFJldHVybnMgdGhlIGluZGl2aWR1YWwgc3ByaXRlcyBmcm9tIHRoZSBhdGxhcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhdGxhc1RvU3ByaXRlcyhzcHJpdGVzaGVldDogSFRNTEltYWdlRWxlbWVudCwgZGVmaW5pdGlvbjogKE9iamVjdCB8IFhNTERvY3VtZW50KSwgb3B0aW9uczogQXRsYXNUb1Nwcml0ZXNPcHRpb25zID0ge30pOiBBcnJheTxTcHJpdGU+IHtcclxuICBjb25zdCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSE7XHJcblxyXG4gIC8vIElmIHRoZSBgYXRsYXNgIGlzIG5vdCBhIGBIVE1MSW1hZ2VFbGVtZW50YCB0aGVuIHdlIHRocm93IGFuIGVycm9yIGFzIHdlIG5vXHJcbiAgLy8gbG9uZ2VyIGhhbmRsZSBsb2FkaW5nIGluIHRoZSBwYXJzZSBtZXRob2RzLlxyXG4gIGlmIChzcHJpdGVzaGVldCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgPT09IGZhbHNlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhdGxhcyBwcm92aWRlZCBpcyBub3QgYSBgSFRNTEltYWdlRWxlbWVudGAuIElmIHlvdSBuZWVkIHRvIGxvYWQgdGhlIGF0bGFzIGZpcnN0LCB1c2UgdGhlIGxvYWRlciBtZXRob2RzIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSBwYXJzZXIuJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzcHJpdGVzOiBBcnJheTxTcHJpdGU+ID0gW107XHJcblxyXG4gIC8vIEZpbmQgb3V0IHdoYXQgdHlwZSBvZiBkYXRhIHdhcyBwcm92aWRlZCwgWE1MIG9yIEpTT04uIElmIGl0J3MgbmVpdGhlciBvZlxyXG4gIC8vIHRob3NlIHRoZW4gd2UgdGhyb3cgYW4gZXJyb3IuXHJcbiAgbGV0IGRhdGFUeXBlO1xyXG4gIGlmIChkZWZpbml0aW9uIGluc3RhbmNlb2YgWE1MRG9jdW1lbnQpIGRhdGFUeXBlID0gJ3htbCc7XHJcbiAgZWxzZSBpZiAoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIE9iamVjdCkgZGF0YVR5cGUgPSAnanNvbic7XHJcbiAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZWZpbml0aW9uIG11c3QgYmUgZWl0aGVyIFhNTCBvciBKU09OJyk7XHJcblxyXG4gIHN3aXRjaCAoZGF0YVR5cGUpIHtcclxuICAgIGNhc2UgJ3htbCc6XHJcbiAgICAgIGNvbnN0IHhtbERlZmluaXRpb24gPSBkZWZpbml0aW9uIGFzIFhNTERvY3VtZW50O1xyXG5cclxuICAgICAgLy8gV2Ugd2FudCB0byBnZXQgYWxsIG5vZGVzIHRoYXQgaGF2ZSBhIGBuYW1lYCwgYHhgLCBhbmQgYHlgLCBgd2lkdGhgLCBhbmQgXHJcbiAgICAgIC8vIGBoZWlnaHRgIGF0dHJpYnV0ZXMuXHJcbiAgICAgIGxldCBzcHJpdGVFbnRyaWVzOiBOb2RlTGlzdE9mPEF0bGFzU3ByaXRlRGF0YT4gPSB4bWxEZWZpbml0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ1t4XVt5XVt3aWR0aF1baGVpZ2h0XScpO1xyXG5cclxuICAgICAgLy8gSWYgdGhlIGFib3ZlIGlzIGVtcHR5IHRoZW4gbWF5YmUgdGhlIGBoZWlnaHRgIGFuZCBgd2lkdGhgIGF0dHJpYnV0ZXMgYXJlXHJcbiAgICAgIC8vIGFjdHVhbGx5IGB3YCBvciBgaGAgc28gd2UgY2hlY2sgZm9yIHRoYXQuXHJcbiAgICAgIGlmIChzcHJpdGVFbnRyaWVzLmxlbmd0aCA9PT0gMCkgc3ByaXRlRW50cmllcyA9IHhtbERlZmluaXRpb24ucXVlcnlTZWxlY3RvckFsbCgnW3hdW3ldW3ddW2hdJyk7XHJcblxyXG4gICAgICAvLyBJZiBib3RoIG9mIHRob3NlIGFyZSBzdGlsbCBlbXB0eSB0aGVuIHdlIGNhbid0IHByb2NlZWQuIE1heWJlIGluIGxhdGVyXHJcbiAgICAgIC8vIHVwZGF0ZXMgd2UnbGwgbWFrZSB0aGlzIG1vcmUgZmxleGlibGUgYnV0IEkgaGF2ZW4ndCBmb3VuZCBjYXNlcyBmb3IgaXRcclxuICAgICAgLy8geWV0IGluIHRoZSBhdGxhcycgSSd2ZSB1c2VkLlxyXG4gICAgICBpZiAoc3ByaXRlRW50cmllcy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYW55IHJvd3Mgd2l0aCBgeGAsIGB5YCwgYHdpZHRoYCwgb3IgYGhlaWdodGAgYXR0cmlidXRlcycpO1xyXG5cclxuICAgICAgc3ByaXRlRW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcclxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBzcHJpdGUncyB3aWR0aCBhbmQgaGVpZ2h0IGFuZCBzZWUgaWYgYSBgcm90YXRlZGAgYXR0cmlidXRlIGV4aXN0cy5cclxuICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KGVudHJ5LmdldEF0dHJpYnV0ZSgnd2lkdGgnKSEgfHwgZW50cnkuZ2V0QXR0cmlidXRlKCd3JykhKTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChlbnRyeS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpISB8fCBlbnRyeS5nZXRBdHRyaWJ1dGUoJ2gnKSEpO1xyXG5cclxuICAgICAgICBjb25zdCBpc1JvdGF0ZWQgPSBCb29sZWFuKGVudHJ5LmdldEF0dHJpYnV0ZSgncm90YXRlZCcpKTtcclxuICAgICAgICBjb25zdCBzcHJpdGVXaWR0aCA9IGlzUm90YXRlZCA/IGhlaWdodCA6IHdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZUhlaWdodCA9IGlzUm90YXRlZCA/IHdpZHRoIDogaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoIXNwcml0ZVdpZHRoIHx8ICFzcHJpdGVIZWlnaHQpIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYSB3aWR0aCBvciBoZWlnaHQgZm9yIHRoZSBzcHJpdGUgZW50cmllcycpO1xyXG5cclxuICAgICAgICBjb25zdCB4ID0gcGFyc2VJbnQoZW50cnkuZ2V0QXR0cmlidXRlKCd4JykhKTtcclxuICAgICAgICBjb25zdCB5ID0gcGFyc2VJbnQoZW50cnkuZ2V0QXR0cmlidXRlKCd5JykhKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBjYW52YXMgdG8gdGhlIHNpemUgb2YgdGhlIHNwcml0ZSBhbmQgdGhlbiBkcmF3IHRoZSBzcHJpdGUgb250byB0aGUgY2FudmFzLlxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHNwcml0ZVdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzcHJpdGVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2Uoc3ByaXRlc2hlZXQsIHgsIHksIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQsIDAsIDAsIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQpO1xyXG5cclxuICAgICAgICBjb25zdCBzcHJpdGVJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIHNwcml0ZUltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpLnJlcGxhY2UoJ2ltYWdlL3BuZycsICdpbWFnZS9vY3RldC1zdHJlYW0nKTtcclxuXHJcbiAgICAgICAgLy8gTGFzdGx5IHdlIGNyZWF0ZSB0aGUgdGhlIFNwcml0ZSBvYmplY3QgYW5kIGFkZCBpdCB0byBgc3ByaXRlc2AuXHJcbiAgICAgICAgY29uc3Qgc3ByaXRlOiBTcHJpdGUgPSB7XHJcbiAgICAgICAgICBuYW1lOiBlbnRyeS5nZXRBdHRyaWJ1dGUoJ25hbWUnKSEsXHJcbiAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgeTogeSxcclxuICAgICAgICAgIHdpZHRoOiBzcHJpdGVXaWR0aCxcclxuICAgICAgICAgIGhlaWdodDogc3ByaXRlSGVpZ2h0LFxyXG4gICAgICAgICAgaXNSb3RhdGVkOiBpc1JvdGF0ZWQsXHJcbiAgICAgICAgICBpbWFnZTogc3ByaXRlSW1hZ2UsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBzcHJpdGVzLnB1c2goc3ByaXRlKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnanNvbic6XHJcbiAgICAgIGNvbnN0IGpzb25EZWZpbml0aW9uOiBhbnkgPSBkZWZpbml0aW9uIGFzIE9iamVjdDtcclxuXHJcbiAgICAgIC8vIElmIGEgcHJvcGVydHkgcGF0aCBhcyBwcm92aWRlZCBpbiB0aGUgb3B0aW9ucyB0aGVuIHdlIHVzZSB0aGF0IG90aGVyd2lzZSB3ZSB1c2UgdGhlIGRlZmF1bHQgb25lLlxyXG4gICAgICBjb25zdCBqc29uUHJvcGVydHlQYXRoID0gb3B0aW9ucy5qc29uUHJvcGVydHlQYXRoID8gb3B0aW9ucy5qc29uUHJvcGVydHlQYXRoIDogJ2ZyYW1lcy4kLmZyYW1lJztcclxuICAgICAgLy8gU3BsaXQgdGhlIHByb3BlcnR5IHBhdGggb24gcGVyaW9kcyBzbyB0aGF0IHdlIGNhbiB1c2UgaXQgdG8gbmF2aWdhdGUgdGhlIG9iamVjdC5cclxuICAgICAgY29uc3QgcHJvcGVydHlQYXRoU3BsaXQgPSBqc29uUHJvcGVydHlQYXRoLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgICAvLyBXZSBuZWVkIHRvIGtub3cgdGhlIGluZGV4IG9mIHRoZSAnJCcgY2hhcmFjdGVyIHdoaWNoIGRlbm90ZXMgdGhlIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlXHJcbiAgICAgIC8vIGluZGl2aWR1YWwgc3ByaXRlXHJcbiAgICAgIGNvbnN0IGluZGV4T2ZTcHJpdGUgPSBwcm9wZXJ0eVBhdGhTcGxpdC5pbmRleE9mKCckJyk7XHJcbiAgICAgIGNvbnN0IHByb3BlcnR5UGF0aEJlZm9yZVNwcml0ZSA9IHByb3BlcnR5UGF0aFNwbGl0LnNwbGljZSgwLCBpbmRleE9mU3ByaXRlKTtcclxuXHJcbiAgICAgIC8vIE5vdyB3ZSBnZXQgdGhlIHBhcnQgb2YgdGhlIGFycmF5IHVwIHVudGlsIGBwcm9wZXJ0eVBhdGhCZWZvcmVTcHJpdGVgIHNvIHRoYXQgd2UgY2FuIGdldCB0aGVcclxuICAgICAgLy8gcGFydHMgb2YgdGhlIG9iamVjdCB0aGF0IHdlIGNhbiBpdGVyYXRlLiBcclxuICAgICAgbGV0IGFsbFNwcml0ZXNJbkpTT04gPSBqc29uRGVmaW5pdGlvbjtcclxuICAgICAgcHJvcGVydHlQYXRoQmVmb3JlU3ByaXRlLmZvckVhY2gocHJvcGVydHkgPT4gYWxsU3ByaXRlc0luSlNPTiA9IGFsbFNwcml0ZXNJbkpTT05bcHJvcGVydHldKTtcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBwcm9wZXJ0eVBhdGhTcGxpdCB3aXRob3V0IHRoZSAkIGVsZW1lbnQuXHJcbiAgICAgIGNvbnN0IHByb3BlcnR5RGV0YWlsc1BhdGggPSBwcm9wZXJ0eVBhdGhTcGxpdC5zbGljZSgxKTtcclxuXHJcbiAgICAgIGZvciAobGV0IHNwcml0ZURldGFpbHMgaW4gYWxsU3ByaXRlc0luSlNPTikge1xyXG4gICAgICAgIGxldCBzcHJpdGVFbnRyeTogYW55ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhbGxTcHJpdGVzSW5KU09OW3Nwcml0ZURldGFpbHNdKSk7XHJcblxyXG4gICAgICAgIC8vIEZvciBlYWNoIHNwcml0ZSBpbiB0aGUgSlNPTiB3ZSBoYXZlIHRvIGZpbmlzaCB0aGUgb2JqZWN0IGxvb2t1cCB3aXRoIHRoZSByZW1haW5pbmcgdmFsdWVzXHJcbiAgICAgICAgLy8gb2YgdGhlIGBwcm9wZXJ0eURldGFpbHNQYXRoYC5cclxuICAgICAgICBwcm9wZXJ0eURldGFpbHNQYXRoLmZvckVhY2gocHJvcGVydHkgPT4gc3ByaXRlRW50cnkgPSBzcHJpdGVFbnRyeVtwcm9wZXJ0eV0pO1xyXG5cclxuICAgICAgICBjb25zdCBlbnRyeTogQXRsYXNTcHJpdGVEYXRhID0gc3ByaXRlRW50cnk7XHJcblxyXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIHNwcml0ZSdzIHdpZHRoIGFuZCBoZWlnaHQgYW5kIHNlZSBpZiB3ZSBuZWVkIHRvIHJvdGF0ZSBpdC5cclxuICAgICAgICBjb25zdCB3aWR0aCA9IGVudHJ5LndpZHRoIHx8IGVudHJ5Lnc7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuaGVpZ2h0IHx8IGVudHJ5Lmg7XHJcbiAgICAgICAgY29uc3QgaXNSb3RhdGVkID0gZW50cnkucm90YXRlZCB8fCBhbGxTcHJpdGVzSW5KU09OW3Nwcml0ZURldGFpbHNdLnJvdGF0ZWQgfHwgZmFsc2U7XHJcblxyXG4gICAgICAgIGNvbnN0IHNwcml0ZVdpZHRoID0gaXNSb3RhdGVkID8gaGVpZ2h0IDogd2lkdGg7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlSGVpZ2h0ID0gaXNSb3RhdGVkID8gd2lkdGggOiBoZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICghc3ByaXRlV2lkdGggfHwgIXNwcml0ZUhlaWdodCkgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhIHdpZHRoIG9yIGhlaWdodCBmb3IgdGhlIHNwcml0ZSBlbnRyaWVzJyk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgY2FudmFzIHRvIHRoZSBzaXplIG9mIHRoZSBzcHJpdGUuXHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gc3ByaXRlV2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHNwcml0ZUhlaWdodDtcclxuXHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShzcHJpdGVzaGVldCwgZW50cnkueCwgZW50cnkueSwgc3ByaXRlV2lkdGgsIHNwcml0ZUhlaWdodCwgMCwgMCwgc3ByaXRlV2lkdGgsIHNwcml0ZUhlaWdodCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNwcml0ZUltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgc3ByaXRlSW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykucmVwbGFjZSgnaW1hZ2UvcG5nJywgJ2ltYWdlL29jdGV0LXN0cmVhbScpO1xyXG5cclxuICAgICAgICAvLyBMYXN0bHkgd2UgY3JlYXRlIHRoZSBTcHJpdGUgb2JqZWN0IGFuZCBhZGQgaXQgdG8gYHNwcml0ZXNgLlxyXG4gICAgICAgIGNvbnN0IHNwcml0ZTogU3ByaXRlID0ge1xyXG4gICAgICAgICAgbmFtZTogZW50cnkubmFtZSB8fCBzcHJpdGVEZXRhaWxzLFxyXG4gICAgICAgICAgeDogZW50cnkueCxcclxuICAgICAgICAgIHk6IGVudHJ5LnksXHJcbiAgICAgICAgICB3aWR0aDogc3ByaXRlV2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IHNwcml0ZUhlaWdodCxcclxuICAgICAgICAgIGlzUm90YXRlZDogaXNSb3RhdGVkLFxyXG4gICAgICAgICAgaW1hZ2U6IHNwcml0ZUltYWdlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc3ByaXRlcy5wdXNoKHNwcml0ZSk7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICBpZiAob3B0aW9ucy5kb3dubG9hZCkgZG93bmxvYWRTcHJpdGVzKHNwcml0ZXMpO1xyXG5cclxuICByZXR1cm4gc3ByaXRlcztcclxufSJdfQ==